{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This website is a hyperlinked twin of the Spoofax project repository shown at the top right.</p> <p>The icons  and  toggle between light and dark mode.</p> <p>Hyperlinked twins support precise name-based code navigation using ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the corresponding declaration.</li> <li>Hover<sup>1</sup> over a name to show the location of the declaration.</li> <li>Click on a declaration to jump to the first reference to it (if any),   or hover over it to show the locations of all the (direct) references to it.</li> </ul> <p>The sources of the webpages were generated by Spoofax from raw code, in the same way as for other hyperlinked twins. The aim is for a future release of Spoofax to support generation of hyperlinked twins for code in all Spoofax meta-languages.</p> <p>Warning</p> <p>The Spoofax implementation and the generated website have not yet been reviewed by the Spoofax developers.</p> <ol> <li> <p>Mobile devices with touch screens don't usually recognise hovering gestures.\u00a0\u21a9</p> </li> </ol>"},{"location":"stratego.lang/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/StrategoLang-namespaced.sdf3/","title":"<code>StrategoLang-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/StrategoLang-namespaced\n\nimports\n  StrategoLang/import-namespaced        \n  StrategoLang/core/modules-namespaced\n\ncontext-free start-symbols StrategoLang-Module\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/StrategoLang-namespaced.sdf3/#modal-h2","title":"StrategoLang-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/deduplicated-namespaced.sdf3/","title":"<code>deduplicated-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/deduplicated-namespaced\n\nimports\n  StrategoLang/core/terms-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/sugar/terms-namespaced        \n  StrategoLang/sugar/rules-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/sugar/dynamic-rules-namespaced        \n  StrategoLang/sugar/string-quotations-namespaced        \n  StrategoLang/gradual-types/signatures-namespaced        \n  StrategoLang/gradual-types/strategies-namespaced\n\ncontext-free syntax\n\n  StrategoLang-PreTerm.As = &lt;&lt;StrategoLang-Var&gt;@&lt;StrategoLang-PreTerm&gt;&gt; { }\n\ncontext-free syntax\n\n  StrategoLang-SortDef.SortVar = StrategoLang-LCID {deprecated(\"This syntax never had a clear meaning should not be used\")}\n  StrategoLang-SortDef.SortNoArgs = StrategoLang-UCID { }\n  StrategoLang-SortDef.Sort = [[StrategoLang-UCID]([{StrategoLang-Kind \", \"}*])] { }\n  StrategoLang-SortDef.Sort = &lt;&lt;StrategoLang-Id&gt;(&lt;{StrategoLang-Sort \", \"}+&gt;)&gt; {deprecated(\"This syntax never had a clear meaning should be replaced by the version that uses kinds A(*, *)\")}\n  StrategoLang-SortDef.ExtSort = [external [StrategoLang-UCID]([{StrategoLang-Kind \", \"}*])] { }\n  StrategoLang-OpType.FunType = [[{StrategoLang-ConstType \" * \"}+] -&gt; [StrategoLang-ConstType]] { }\n\ncontext-free syntax\n\n  StrategoLang-PreTerm.App = [&lt;[StrategoLang-Strategy]&gt; [StrategoLang-Term]] { }\n  StrategoLang-PreTerm.RootApp = [&lt;[StrategoLang-Strategy]&gt;] { }\n\ncontext-free syntax\n\n  StrategoLang-Def.AnnoDef = &lt;&lt;StrategoLang-Anno+&gt; &lt;StrategoLang-RuleDef&gt;&gt; { }\n\nsyntax\n\n  StrategoLang-Strategy-CF.DynRuleUnionFix = \"\\\\\" LAYOUT?-CF StrategoLang-RuleNames-CF \" /*\" LAYOUT?-CF StrategoLang-Strategy-CF { }\n  StrategoLang-Strategy-CF.DynRuleIntersectUnionFix = \"/\" LAYOUT?-CF StrategoLang-RuleNames-CF LAYOUT?-CF \"\\\\\" LAYOUT?-CF StrategoLang-RuleNames-CF \" /*\" LAYOUT?-CF StrategoLang-Strategy-CF { }\n\ncontext-free syntax\n\n  StrategoLang-StringQuotedPart1.QStr = StrategoLang-StringQuotedChars1 { }\n  StrategoLang-StringQuotedPart2.QStr = StrategoLang-StringQuotedChars2 { }\n  StrategoLang-StringQuotedPart3.QStr = StrategoLang-StringQuotedChars3 { }\n  StrategoLang-StringQuotedPart4.QStr = StrategoLang-StringQuotedChars4 { }\n  StrategoLang-StringQuotedPart1.QDollar = StrategoLang-Dollar1 { }\n  StrategoLang-StringQuotedPart2.QDollar = StrategoLang-Dollar2 { }\n  StrategoLang-StringQuotedPart3.QDollar = StrategoLang-Dollar3 { }\n  StrategoLang-StringQuotedPart4.QDollar = StrategoLang-Dollar4 { }\n  StrategoLang-StringQuotedPart1.QBr = StrategoLang-QuotedBracket1 { }\n  StrategoLang-StringQuotedPart2.QBr = StrategoLang-QuotedBracket2 { }\n  StrategoLang-StringQuotedPart3.QBr = StrategoLang-QuotedBracket3 { }\n  StrategoLang-StringQuotedPart4.QBr = StrategoLang-QuotedBracket4 { }\n\ncontext-free syntax\n\n  StrategoLang-ConstType.DynT = StrategoLang-Dyn { }\n  StrategoLang-SortT.Sort = [[StrategoLang-Id]([{StrategoLang-Type \", \"}*])] { }\n  StrategoLang-SortT.SortNoArgs = StrategoLang-UCID { }\n  StrategoLang-SortT.SortVar = StrategoLang-SortVar { }\n  StrategoLang-SortArg.TupleT = [[StrategoLang-Sort] * [{StrategoLang-Sort \" * \"}+]] { }\n  StrategoLang-SortArg.DynT = StrategoLang-Dyn { }\n  StrategoLang-SFunType.FunType = [([{StrategoLang-SType \", \"}*]) [StrategoLang-SSimpleFunType]] { }\n\ncontext-free syntax\n\n  StrategoLang-Coercion.Fail = [fail] { }\n  StrategoLang-Coercion.Id = [id] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/deduplicated-namespaced.sdf3/#modal-h2","title":"deduplicated-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/import-namespaced.sdf3/","title":"<code>import-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/import-namespaced\n\nimports\n  StrategoLang/sugar/main-namespaced        \n  StrategoLang/core/main-namespaced        \n  StrategoLang/gradual-types/main-namespaced\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/import-namespaced.sdf3/#modal-h2","title":"import-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/permissive-water-namespaced.sdf3/","title":"<code>permissive-water-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/permissive-water-namespaced\n\n\ncontext-free syntax\n\n  LAYOUT.WATER = StrategoLang-WATER { }\n\nsorts WATER-LEX WATERTOKEN-LEX WATERTOKENSTART-LEX WATERTOKENSEPARATOR-LEX\n\nlexical syntax\n\n  StrategoLang-WATER = StrategoLang-WATERTOKEN { }\n  StrategoLang-WATER = StrategoLang-WATERTOKENSEPARATOR { }\n  StrategoLang-WATERTOKEN = StrategoLang-WATERTOKENSTART [A-Za-z0-9\\_]* { }\n  StrategoLang-WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n  StrategoLang-WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n\n  StrategoLang-WATERTOKEN -/- [A-Za-z0-9\\_]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/permissive-water-namespaced.sdf3/#modal-h2","title":"permissive-water-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/constants-namespaced.sdf3/","title":"<code>constants-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/constants-namespaced\n\n\nsorts Int-LEX Real-LEX String-LEX StrChar-LEX\n\nlexical syntax\n\n  StrategoLang-Int = [\\-]? [0-9]+ { }\n  StrategoLang-Real = [\\-]? [0-9]+ [\\.] [0-9]+ { }\n  StrategoLang-String = \"\\\"\" StrategoLang-StrChar* \"\\\"\" { }\n  StrategoLang-StrChar = ~[\\\"\\\\] { }\n  StrategoLang-StrChar = [\\\\] [tnrbf\\\"\\'\\\\] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/constants-namespaced.sdf3/#modal-h2","title":"constants-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/identifiers-namespaced.sdf3/","title":"<code>identifiers-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/identifiers-namespaced\n\n\nsorts ModName-LEX ModNamePart-LEX\n\nlexical syntax\n\n  StrategoLang-ModName = {StrategoLang-ModNamePart \"/\"}+ { }\n  StrategoLang-ModNamePart = [a-zA-Z\\.\\_] [a-zA-Z0-9\\'\\.\\-\\_]* { }\n\nlexical restrictions\n\n  StrategoLang-ModName -/- [a-zA-Z0-9\\'\\.\\-\\_]\n\ncontext-free syntax\n\n  StrategoLang-ModName = \"imports\" {reject}\n  StrategoLang-ModName = \"overlays\" {reject}\n  StrategoLang-ModName = \"rules\" {reject}\n  StrategoLang-ModName = \"signature\" {reject}\n  StrategoLang-ModName = \"strategies\" {reject}\n\nsorts Id-LEX LId-LEX LCID-LEX UCID-LEX SortVar-LEX BuiltInType-LEX SomeSort-LEX\n\nlexical syntax\n\n  StrategoLang-Id = [a-zA-Z] [a-zA-Z0-9\\'\\-\\_]* { }\n  StrategoLang-LId = [a-zA-Z] [a-zA-Z0-9\\'\\-\\_]* \"*\" { }\n  StrategoLang-Id = [\\'] [a-z]+ { }\n  StrategoLang-LCID = [a-z] [a-zA-Z0-9\\'\\-\\_]* { }\n  StrategoLang-UCID = [A-Z] [a-zA-Z0-9\\'\\-\\_]* { }\n  StrategoLang-SortVar = StrategoLang-LCID { }\n  StrategoLang-SortVar = StrategoLang-BuiltInType {reject}\n  StrategoLang-BuiltInType = \"string\" { }\n  StrategoLang-BuiltInType = \"int\" { }\n  StrategoLang-BuiltInType = \"real\" { }\n  StrategoLang-BuiltInType = \"blob\" { }\n\nlexical restrictions\n\n  StrategoLang-Id -/- [a-zA-Z0-9\\'\\_\\*]\n  StrategoLang-Id -/- [\\-].~[\\&gt;]\n  StrategoLang-LId -/- [a-zA-Z0-9\\'\\-\\_]\n  StrategoLang-LCID -/- [a-zA-Z0-9\\'\\-\\_]\n  StrategoLang-UCID -/- [a-zA-Z0-9\\'\\-\\_]\n\nlexical syntax\n\n  StrategoLang-Id = \"_\" {reject}\n  StrategoLang-Id = \"'\" {reject}\n  StrategoLang-Id = StrategoLang-Keyword {reject}\n  StrategoLang-Lid = StrategoLang-Keyword {reject}\n  StrategoLang-LCID = StrategoLang-Keyword {reject}\n  StrategoLang-UCID = StrategoLang-Keyword {reject}\n\nsorts Keyword-LEX\n\nlexical syntax\n\n  StrategoLang-Keyword = \"all\" { }\n  StrategoLang-Keyword = \"constructors\" { }\n  StrategoLang-Keyword = \"fail\" { }\n  StrategoLang-Keyword = \"id\" { }\n  StrategoLang-Keyword = \"in\" { }\n  StrategoLang-Keyword = \"let\" { }\n  StrategoLang-Keyword = \"module\" { }\n  StrategoLang-Keyword = \"not\" { }\n  StrategoLang-Keyword = \"one\" { }\n  StrategoLang-Keyword = \"overlays\" { }\n  StrategoLang-Keyword = \"prim\" { }\n  StrategoLang-Keyword = \"proceed\" { }\n  StrategoLang-Keyword = \"rules\" { }\n  StrategoLang-Keyword = \"script\" { }\n  StrategoLang-Keyword = \"signature\" { }\n  StrategoLang-Keyword = \"some\" { }\n  StrategoLang-Keyword = \"sorts\" { }\n  StrategoLang-Keyword = \"strategies\" { }\n  StrategoLang-Keyword = \"stratego\" { }\n  StrategoLang-Keyword = \"test\" { }\n  StrategoLang-Keyword = \"where\" { }\n  StrategoLang-Keyword = \"import-term\" { }\n  StrategoLang-Keyword = \"is\" { }\n\nlexical restrictions\n\n  \"all\"\n  \"case\"\n  \"constructors\"\n  \"else\"\n  \"end\"\n  \"external\"\n  \"fail\"\n  \"id\"\n  \"if\"\n  \"in\"\n  \"is\"\n  \"imports\"\n  \"let\"\n  \"module\"\n  \"not\"\n  \"one\"\n  \"overlays\"\n  \"otherwise\"\n  \"prim\"\n  \"proceed\"\n  \"rec\"\n  \"rules\"\n  \"script\"\n  \"signature\"\n  \"some\"\n  \"sorts\"\n  \"strategies\"\n  \"stratego\"\n  \"switch\"\n  \"test\"\n  \"then\"\n  \"where\"\n  \"with\"\n  \"import-term\" -/- [a-zA-Z0-9\\'\\-\\_]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/identifiers-namespaced.sdf3/#modal-h2","title":"identifiers-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/layout-namespaced.sdf3/","title":"<code>layout-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/layout-namespaced\n\n\nsorts Ws-LEX ShortCom-LEX LongCom-LEX CommChar-LEX Asterisk-LEX Eof-LEX\n\nlexical syntax\n\n  StrategoLang-Ws = [\\t\\ \\n\\r] { }\n  StrategoLang-ShortCom = \"//\" ~[\\n\\r]* [\\n\\r] | StrategoLang-Eof { }\n  StrategoLang-LongCom = \"/*\" StrategoLang-CommChar* \"*/\" { }\n  StrategoLang-Eof = { }\n  StrategoLang-CommChar = ~[\\*] { }\n  StrategoLang-Asterisk = \"*\" { }\n  StrategoLang-CommChar = StrategoLang-Asterisk { }\n\nlexical restrictions\n\n  StrategoLang-Asterisk -/- [\\/]\n  StrategoLang-Eof -/- ~[ ]\n\nlexical syntax\n\n  LAYOUT = StrategoLang-ShortCom { }\n  LAYOUT = StrategoLang-LongCom { }\n  LAYOUT = StrategoLang-Ws { }\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\*]\n  LAYOUT? -/- [\\/].[\\/]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/layout-namespaced.sdf3/#modal-h2","title":"layout-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/main-namespaced.sdf3/","title":"<code>main-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/main-namespaced\n\nimports\n  StrategoLang/core/constants-namespaced        \n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/layout-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/core/terms-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/core/modules-namespaced\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/main-namespaced.sdf3/#modal-h2","title":"main-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/modules-namespaced.sdf3/","title":"<code>modules-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/modules-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/layout-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/core/strategies-namespaced\n\nsorts StrategoLang-Module\n\ncontext-free syntax\n\n  StrategoLang-Module.Module = &lt;module &lt;StrategoLang-ModName&gt;\n\n&lt;{StrategoLang-AnnoDecl \"\\n\\n\"}*&gt;&gt; { }\n  StrategoLang-Module.Specification = &lt;specification\n\n&lt;{StrategoLang-AnnoDecl \"\\n\\n\"}*&gt;&gt; { }\n\nsorts StrategoLang-Decl StrategoLang-AnnoDecl\n\ncontext-free syntax\n\n  StrategoLang-Decl.Imports = &lt;imports\n\n&lt;{StrategoLang-ImportModName \"\\n\"}*&gt;&gt; { }\n  StrategoLang-Decl.Strategies = &lt;strategies\n\n&lt;{StrategoLang-Def \"\\n\\n\"}*&gt;&gt; { }\n  StrategoLang-Decl.Signature = &lt;signature\n&lt;{StrategoLang-Sdecl \"\\n\\n\"}*&gt;&gt; { }\n  StrategoLang-AnnoDecl = StrategoLang-Decl { }\n\nsorts StrategoLang-ImportModName\n\ncontext-free syntax\n\n  StrategoLang-ImportModName.Import = StrategoLang-ModName { }\n\nsyntax\n\n  StrategoLang-ImportModName-CF.ImportWildcard = StrategoLang-ModName-CF \"/\" \"-\" { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/modules-namespaced.sdf3/#modal-h2","title":"modules-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/signatures-namespaced.sdf3/","title":"<code>signatures-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/signatures-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/constants-namespaced\n\nsorts StrategoLang-Kind\n\ncontext-free syntax\n\n  StrategoLang-Kind.Star = &lt;*&gt; { }\n\nsorts StrategoLang-SortDef\n\ncontext-free syntax\n\n  StrategoLang-SortDef.SortDefVar = StrategoLang-LCID {deprecated(\"This syntax never had a clear meaning should not be used\")}\n  StrategoLang-SortDef.SortDefNoArgs = StrategoLang-UCID { }\n  StrategoLang-SortDef.SortDef = [[StrategoLang-UCID]([{StrategoLang-Kind \", \"}*])] { }\n  StrategoLang-SortDef.SortDefDepr = &lt;&lt;StrategoLang-Id&gt;(&lt;{StrategoLang-Sort \", \"}+&gt;)&gt; {deprecated(\"This syntax never had a clear meaning should be replaced by the version that uses kinds A(*, *)\")}\n  StrategoLang-SortDef.ExtSortDef = [external [StrategoLang-UCID]([{StrategoLang-Kind \", \"}*])] { }\n\nsorts StrategoLang-Sdecl\n\ncontext-free syntax\n\n  StrategoLang-Sdecl.Sorts = &lt;sorts &lt;StrategoLang-SortDef*&gt;&gt; { }\n  StrategoLang-Sdecl.Constructors = &lt;constructors\n\n&lt;{StrategoLang-Opdecl \"\\n\"}*&gt;&gt; { }\n\nsorts StrategoLang-Sort StrategoLang-SortArg\n\ncontext-free syntax\n\n  StrategoLang-Sort.SortVar = StrategoLang-LCID { }\n  StrategoLang-Sort.SortNoArgs = StrategoLang-UCID { }\n  StrategoLang-Sort.Sort = &lt;&lt;StrategoLang-Id&gt;(&lt;{StrategoLang-SortArg \", \"}*&gt;)&gt; { }\n  StrategoLang-SortArg = StrategoLang-Sort { }\n\nsorts StrategoLang-Opdecl\n\ncontext-free syntax\n\n  StrategoLang-Opdecl.OpDecl = &lt;&lt;StrategoLang-Id&gt; : &lt;StrategoLang-OpType&gt;&gt; { }\n  StrategoLang-Opdecl.OpDeclQ = &lt;&lt;StrategoLang-String&gt; : &lt;StrategoLang-OpType&gt;&gt; { }\n  StrategoLang-Opdecl.OpDeclInj = &lt;: &lt;StrategoLang-OpType&gt;&gt; { }\n  StrategoLang-Opdecl.ExtOpDecl = &lt;external &lt;StrategoLang-Id&gt; : &lt;StrategoLang-OpType&gt;&gt; { }\n  StrategoLang-Opdecl.ExtOpDeclQ = &lt;external &lt;StrategoLang-String&gt; : &lt;StrategoLang-OpType&gt;&gt; { }\n  StrategoLang-Opdecl.ExtOpDeclInj = &lt;external : &lt;StrategoLang-OpType&gt;&gt; { }\n\nsorts StrategoLang-OldType StrategoLang-OldArgType StrategoLang-ConstType StrategoLang-FunType StrategoLang-RetType StrategoLang-OpType\n\ncontext-free syntax\n\n  StrategoLang-ConstType.ConstType = StrategoLang-Sort { }\n  StrategoLang-FunType.FunType = [[{StrategoLang-OldArgType \" * \"}+] -&gt; [StrategoLang-RetType]] { }\n  StrategoLang-OldArgType = &lt;(&lt;StrategoLang-OldType&gt;)&gt; {bracket}\n  StrategoLang-OldArgType = StrategoLang-ConstType { }\n  StrategoLang-RetType = StrategoLang-OldType { }\n  StrategoLang-RetType = StrategoLang-FunType {reject}\n  StrategoLang-OldType = StrategoLang-FunType { }\n  StrategoLang-OldType = StrategoLang-ConstType { }\n  StrategoLang-OpType = StrategoLang-ConstType { }\n  StrategoLang-OpType.OpFunType = [[{StrategoLang-ConstType \" * \"}+] -&gt; [StrategoLang-ConstType]] { }\n\ncontext-free restrictions\n\n  StrategoLang-Sort -/- [\\(]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/signatures-namespaced.sdf3/#modal-h2","title":"signatures-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/strategies-namespaced.sdf3/","title":"<code>strategies-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/strategies-namespaced\n\nimports\n  StrategoLang/core/terms-namespaced        \n  StrategoLang/core/constants-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/core/identifiers-namespaced\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\'\\-\\_]\n  tokenize : \")(|\"\n\nsorts StrategoLang-Def\n\ncontext-free syntax\n\n  StrategoLang-Def = StrategoLang-StrategyDef { }\n\nsorts StrategoLang-StrategyDef StrategoLang-SDefT\n\ncontext-free syntax\n\n  StrategoLang-StrategyDef = StrategoLang-SDefT { }\n  StrategoLang-SDefT.SDefT = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; | &lt;{StrategoLang-Typedid \", \"}*&gt;) =\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n  StrategoLang-Def.AnnoDef = &lt;&lt;StrategoLang-Anno+&gt; &lt;StrategoLang-StrategyDef&gt;&gt; { }\n  StrategoLang-StrategyDef.ExtSDefInl = &lt;external &lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; | &lt;{StrategoLang-Typedid \", \"}*&gt;) =\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n  StrategoLang-StrategyDef.ExtSDef = &lt;external &lt;StrategoLang-MaybeEmptySId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; | &lt;{StrategoLang-Typedid \", \"}*&gt;)&gt; { }\n\nsorts SId-LEX MaybeEmptySId-LEX\n\nlexical syntax\n\n  StrategoLang-SId = StrategoLang-Id { }\n  StrategoLang-MaybeEmptySId = { }\n  StrategoLang-MaybeEmptySId = StrategoLang-SId { }\n\nsorts StrategoLang-Anno\n\ncontext-free syntax\n\n  StrategoLang-Anno.Extend = &lt;extend&gt; { }\n  StrategoLang-Anno.Override = &lt;override&gt; { }\n  StrategoLang-Anno.Internal = &lt;internal&gt; { }\n\nsorts StrategoLang-Typedid\n\ncontext-free syntax\n\n  StrategoLang-Typedid.VarDec = &lt;&lt;StrategoLang-ID&gt; : &lt;StrategoLang-OldType&gt;&gt; { }\n\nsorts StrategoLang-Strategy StrategoLang-SVar\n\ncontext-free syntax\n\n  StrategoLang-Strategy.Fail = &lt;fail&gt; { }\n  StrategoLang-Strategy.Id = &lt;id&gt; { }\n  StrategoLang-Strategy.ProceedT = &lt;proceed(&lt;{StrategoLang-Strategy \", \"}*&gt;|&lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n  StrategoLang-Strategy.ProceedNoArgs = &lt;proceed&gt; { }\n  StrategoLang-Strategy.Match = &lt;?&lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-Strategy.Build = &lt;!&lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-Strategy.Scope = &lt;{&lt;{StrategoLang-ID \", \"}*&gt;: &lt;StrategoLang-Strategy&gt; }&gt; { }\n  StrategoLang-Strategy.Seq = &lt;&lt;StrategoLang-Strategy&gt;; &lt;StrategoLang-Strategy&gt;&gt; {right}\n  StrategoLang-Strategy.GuardedLChoice = [[StrategoLang-Strategy] &lt; [StrategoLang-Strategy] + [StrategoLang-Strategy]] {right}\n  StrategoLang-Strategy.PrimT = &lt;prim(&lt;StrategoLang-String&gt;, &lt;{StrategoLang-Strategy \", \"}*&gt;|&lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n  StrategoLang-Strategy.Some = &lt;some(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-Strategy.One = &lt;one(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-Strategy.All = &lt;all(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-SVar.SVar = StrategoLang-SId { }\n  StrategoLang-Strategy.Let = &lt;let\n  &lt;{StrategoLang-Def \"\\n\"}*&gt;\nin\n  &lt;StrategoLang-Strategy&gt;\nend&gt; { }\n  StrategoLang-Strategy.CallT = &lt;&lt;StrategoLang-SVar&gt;(&lt;{StrategoLang-Strategy \", \"}*&gt;|&lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n  StrategoLang-Strategy.CallDynamic = &lt;call(&lt;StrategoLang-Term&gt;|&lt;{StrategoLang-Strategy \", \"}*&gt;|&lt;{StrategoLang-Term \", \"}*&gt;)&gt; {deprecated(\"Dynamic calls are not supported\")}\n  StrategoLang-Strategy.ImportTerm = &lt;import-term(&lt;StrategoLang-ModName&gt;)&gt; { }\n\ncontext-free priorities\n\n  {StrategoLang-Strategy.Build\n   StrategoLang-Strategy.Match} &gt; StrategoLang-Strategy.Seq &gt; StrategoLang-Strategy.GuardedLChoice\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/strategies-namespaced.sdf3/#modal-h2","title":"strategies-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/terms-namespaced.sdf3/","title":"<code>terms-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/core/terms-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/constants-namespaced\n\nsorts StrategoLang-ID StrategoLang-Var StrategoLang-Wld\n\ncontext-free syntax\n\n  StrategoLang-Var.Var = StrategoLang-ID { }\n  StrategoLang-ID = StrategoLang-Id { }\n  StrategoLang-Wld.Wld = \"_\" { }\n\nsorts StrategoLang-Term\n\ncontext-free syntax\n\n  StrategoLang-Term = StrategoLang-Var { }\n  StrategoLang-Term = StrategoLang-Wld { }\n  StrategoLang-Term.Anno = &lt;&lt;StrategoLang-PreTerm&gt;{^&lt;StrategoLang-PreTerm&gt;}&gt; { }\n  StrategoLang-Term.As = &lt;&lt;StrategoLang-Var&gt;@&lt;StrategoLang-Term&gt;&gt; { }\n\nsorts StrategoLang-PreTerm\n\ncontext-free syntax\n\n  StrategoLang-PreTerm = StrategoLang-Var { }\n  StrategoLang-PreTerm = StrategoLang-Wld { }\n  StrategoLang-PreTerm.Int = StrategoLang-Int { }\n  StrategoLang-PreTerm.Real = StrategoLang-Real { }\n  StrategoLang-PreTerm.Str = StrategoLang-String { }\n  StrategoLang-PreTerm.Op = &lt;&lt;StrategoLang-Id&gt;(&lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n  StrategoLang-PreTerm.OpQ = &lt;&lt;StrategoLang-String&gt;(&lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n  StrategoLang-PreTerm.Explode = &lt;&lt;StrategoLang-Term&gt;#(&lt;StrategoLang-Term&gt;)&gt; { }\n  StrategoLang-PreTerm.AsPT = &lt;&lt;StrategoLang-Var&gt;@&lt;StrategoLang-PreTerm&gt;&gt; { }\n\ncontext-free priorities\n\n  StrategoLang-PreTerm.Explode &gt; StrategoLang-Term.As,\n  StrategoLang-Term.Anno &gt; StrategoLang-PreTerm.AsPT\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/core/terms-namespaced.sdf3/#modal-h2","title":"terms-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/internal-namespaced.sdf3/","title":"<code>internal-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/internal-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/constants-namespaced        \n  StrategoLang/core/modules-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/gradual-types/signatures-namespaced\n\nsorts StrategoLang-Str2Lib StrategoLang-Str2LibComponent StrategoLang-Anno\n\ncontext-free syntax\n\n  StrategoLang-Str2Lib.Str2Lib = [library [StrategoLang-ModNamePart]\n    [{StrategoLang-Str2LibComponent \"\\n\"}+]\n    [{StrategoLang-Module \"\\n\\n\"}+]\n  ] { }\n  StrategoLang-Str2LibComponent.Maven = [maven [groupId:StrategoLang-JavaId]:[id:StrategoLang-JavaId]:[StrategoLang-MavenVersion]] { }\n  StrategoLang-Str2LibComponent.Package = [package [StrategoLang-PackageName]] { }\n  StrategoLang-Anno.Overlay = [overlay] { }\n\nsorts VersionNumber-LEX VersionQualifier-LEX MavenVersion-LEX PackageName-LEX JavaId-LEX\n\nlexical syntax\n\n  StrategoLang-MavenVersion = StrategoLang-VersionNumber \".\" StrategoLang-VersionNumber \".\" StrategoLang-VersionNumber StrategoLang-VersionQualifier { }\n  StrategoLang-VersionNumber = [0-9]+ { }\n  StrategoLang-VersionQualifier = \"-\" [A-Za-z0-9\\-\\.]+ { }\n  StrategoLang-PackageName = {StrategoLang-JavaId \".\"}+ { }\n  StrategoLang-JavaId = [A-Za-z\\_\\$] [A-Za-z0-9\\_\\$]+ { }\n\nlexical restrictions\n\n  StrategoLang-VersionQualifier -/- [A-Za-z0-9\\-\\.]\n\nsorts StrategoLang-ConstrType\n\ncontext-free syntax\n\n  StrategoLang-Def.DefHasType = [[StrategoLang-SId] :: [StrategoLang-SFunType]] { }\n  StrategoLang-Type.IllFormedTermT = [[StrategoLang-Id]#([{StrategoLang-Type \", \"}*])] { }\n  StrategoLang-Type.EmptyT = [empty] { }\n  StrategoLang-Anno.LocalDef = [localdef] { }\n  StrategoLang-Anno.AmbiguousStrategyResolution = [ambiguous strategy resolves to arities: [StrategoLang-Int], [StrategoLang-Int]] { }\n  StrategoLang-SType.SEmptyT = [s-empty] { }\n  StrategoLang-Dyn = StrategoLang-Type { }\n  StrategoLang-ConstrType.ConstrType = [[{StrategoLang-Type \" * \"}+] -&gt; [StrategoLang-Type]] { }\n\nsorts StrategoLang-ErrorDesc StrategoLang-MessageType\n\ncontext-free syntax\n\n  StrategoLang-MessageType.MTError = [error] { }\n  StrategoLang-MessageType.MTWarning = [warning] { }\n  StrategoLang-MessageType.MTNote = [note] { }\n  StrategoLang-ErrorDesc.CallDynamicNotSupported = [The dynamic `call(name|sargs|targs)` construct is no longer supported.] { }\n  StrategoLang-ErrorDesc.TermVariableTypedWithStrategyType = [This term variable was given a strategy type.] { }\n  StrategoLang-ErrorDesc.StrategyVariableTypedWithTermType = [This strategy variable was given a term type.] { }\n  StrategoLang-ErrorDesc.DuplicateTypeDefinition = [Duplicate type definition.] { }\n  StrategoLang-ErrorDesc.MissingDefinitionForTypeDefinition = [Cannot find definition for this type definition.] { }\n  StrategoLang-ErrorDesc.ProceedWrongNumberOfArguments = [Wrong number of arguments to proceed: ([StrategoLang-Int]|[StrategoLang-Int]).] { }\n  StrategoLang-ErrorDesc.ProceedInNonExtendStrategy = [Cannot call proceed in a strategy or rule defined without the `extend` keyword.] { }\n  StrategoLang-ErrorDesc.CallStrategyArgumentTakesParameters = [This call takes parameters, it has type: [StrategoLang-SFunType].] { }\n  StrategoLang-ErrorDesc.AmbiguousStrategyResolution = [Call to strategy was ambiguous, could resolve to the following: [{StrategoLang-SFunType \", \"}+].] { }\n  StrategoLang-ErrorDesc.NormalDefinitionOverlapsWithExternal = [Definition of strategy overlaps with definition of external strategy.] { }\n  StrategoLang-ErrorDesc.NormalDefinitionOverlapsWithInternal = [Definition of strategy overlaps with definition of internal strategy.] { }\n  StrategoLang-ErrorDesc.OverrideDefinitionWithoutExternal = [Cannot find external strategy to override.] { }\n  StrategoLang-ErrorDesc.ExtendDefinitionWithoutExternal = [Cannot find external strategy to extend.] { }\n  StrategoLang-ErrorDesc.NoInjectionBetween = [Cannot convert from [StrategoLang-Type] to [StrategoLang-Type] automatically, no known injection.] { }\n  StrategoLang-ErrorDesc.CastInserted = [Converting from [StrategoLang-Type] to [StrategoLang-Type] with a cast.] { }\n  StrategoLang-ErrorDesc.SCastInserted = [Converting from [StrategoLang-SType] to [StrategoLang-SType] with a cast.] { }\n  StrategoLang-ErrorDesc.VariableBoundToIncompatibleType = [This variable has type [StrategoLang-Type], which cannot be converted to [StrategoLang-Type] automatically.] { }\n  StrategoLang-ErrorDesc.NoLUBBetween = [Expected [StrategoLang-Type] and [StrategoLang-Type] to have a shared least upper bound but none was found.] { }\n  StrategoLang-ErrorDesc.STypeMismatch = [Expected [StrategoLang-SType], but got [StrategoLang-SType].] { }\n  StrategoLang-ErrorDesc.UnresolvedLocal = [Undefined local variable.] { }\n  StrategoLang-ErrorDesc.UnresolvedSort = [Undefined sort with arity [StrategoLang-Int].] { }\n  StrategoLang-ErrorDesc.UnresolvedSortVar = [Undefined sort variable.] { }\n  StrategoLang-ErrorDesc.UnresolvedConstructor = [Undefined constructor with arity [StrategoLang-Int] and type [StrategoLang-Type].] { }\n  StrategoLang-ErrorDesc.UnresolvedStrategy = [Undefined strategy with arity [StrategoLang-Int]/[StrategoLang-Int].] { }\n  StrategoLang-ErrorDesc.AmbiguousConstructorUse = [Ambiguous use of constructor, could be the following types: [{StrategoLang-Type \", \"}+]] { }\n  StrategoLang-ErrorDesc.UnboundTypeVar = [No instantiation found for type variable [StrategoLang-String]] { }\n  StrategoLang-ErrorDesc.LiteralCastFail = [Cannot compile literal failing cast] { }\n  StrategoLang-ErrorDesc.MissingParsingInfoOnStringQuotation = [String quotation does not have parser information required to figure out indentation.] { }\n  StrategoLang-ErrorDesc.StrategyCongruenceOverlap = [Strategy overlaps with congruence for constructor of same name.] { }\n  StrategoLang-ErrorDesc.GadtSort = [Must use all unique sort variables as sort arguments, GADTs are not supported.] { }\n  StrategoLang-ErrorDesc.AsInBuildTerm = [The @ pattern may not be used in build context.] { }\n  StrategoLang-ErrorDesc.WldInBuildTerm = [The _ pattern may not be used in build context.] { }\n  StrategoLang-ErrorDesc.BuildDefaultInBuildTerm = [The _name pattern may not be used in build context.] { }\n  StrategoLang-ErrorDesc.BuildDefaultInMatchTerm = [The _name pattern may not be used in match context.] { }\n  StrategoLang-ErrorDesc.StringQuotationInMatchTerm = [A string quotation pattern may not be used in match context.] { }\n  StrategoLang-ErrorDesc.NonStringOrListInExplodeConsPosition = [Expected type string or list, but got [StrategoLang-Type].] { }\n  StrategoLang-ErrorDesc.NonListInAnno = [Expected list, but got [StrategoLang-Type].] { }\n  StrategoLang-ErrorDesc.MultipleAppsInMatch = [Multiple projections in one pattern, only one is actually returned. ] { }\n  StrategoLang-ErrorDesc.MatchNotSpecificEnoughForTP = [Cannot infer specific type for TP rule match. Found result: [StrategoLang-Type]. ] { }\n  StrategoLang-ErrorDesc.UnsupportedCastRequiredInDynamicRule = [Pattern induces cast, but cast is not supported in this position. ] { }\n  StrategoLang-ErrorDesc.DynRuleOverlapError = [Overlapping left-hand-sides for dynamic rule '[StrategoLang-Id]': [StrategoLang-String] in [StrategoLang-String] overlaps with [StrategoLang-String] in [StrategoLang-String]. ] { }\n  StrategoLang-ErrorDesc.CannotCastToRigidTypeVar = [Cannot cast [StrategoLang-Type] to type [StrategoLang-Type], its type is not known at run-time in this position. ] { }\n  StrategoLang-ErrorDesc.WithClauseInDynRule = [Cannot use with clauses in dynamic rules. ] { }\n  StrategoLang-ErrorDesc.ConstantCongruence = [Simple matching congruence: prefix with '?'. Or with '!' if you meant to build. ] { }\n  StrategoLang-ErrorDesc.WldInOverlay = [Wildcard not allowed in overlay, add a default value after the underscore. ] { }\n  StrategoLang-ErrorDesc.AsInOverlay = [As pattern not allowed in overlay. ] { }\n  StrategoLang-ErrorDesc.StringQuotationInOverlay = [The string quotation pattern may not be used in overlay. ] { }\n  StrategoLang-ErrorDesc.MissingTypeDefinition = [Missing type definition. ] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/internal-namespaced.sdf3/#modal-h2","title":"internal-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/main-namespaced.sdf3/","title":"<code>main-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/main-namespaced\n\nimports\n  StrategoLang/gradual-types/modules-namespaced        \n  StrategoLang/gradual-types/signatures-namespaced        \n  StrategoLang/gradual-types/strategies-namespaced        \n  StrategoLang/gradual-types/terms-namespaced        \n  StrategoLang/gradual-types/overlays-namespaced\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/main-namespaced.sdf3/#modal-h2","title":"main-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/modules-namespaced.sdf3/","title":"<code>modules-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/modules-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/gradual-types/signatures-namespaced\n\ncontext-free syntax\n\n  StrategoLang-Def.DefHasTypeNoArgs = [[StrategoLang-SId] :: [StrategoLang-SSimpleFunType]] { }\n  StrategoLang-Def.DefHasType = [[StrategoLang-SId]([{StrategoLang-SType \", \"}*]) :: [StrategoLang-SSimpleFunType]] { }\n  StrategoLang-Def.DefHasTType = [[StrategoLang-SId]([{StrategoLang-SType \", \"}*] | [{StrategoLang-Type \", \"}*]) :: [StrategoLang-SSimpleFunType]] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/modules-namespaced.sdf3/#modal-h2","title":"modules-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/overlays-namespaced.sdf3/","title":"<code>overlays-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/overlays-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/gradual-types/signatures-namespaced        \n  StrategoLang/sugar/overlays-namespaced\n\ncontext-free syntax\n\n  StrategoLang-Overlay.OverlayDeclNoArgs = [[StrategoLang-Id] :: [StrategoLang-ConstType]] { }\n  StrategoLang-Overlay.OverlayDecl = [[StrategoLang-Id]([{StrategoLang-Type \", \"}*]) :: [StrategoLang-ConstType]] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/overlays-namespaced.sdf3/#modal-h2","title":"overlays-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/signatures-namespaced.sdf3/","title":"<code>signatures-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/signatures-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/signatures-namespaced\n\nsorts StrategoLang-Type StrategoLang-SortT StrategoLang-Dyn\n\ncontext-free syntax\n\n  StrategoLang-ConstType.ConstDynT = StrategoLang-Dyn { }\n  StrategoLang-Dyn.Dyn = [?] { }\n  StrategoLang-Type.TupleT = [[StrategoLang-Type] * [{StrategoLang-Type \" * \"}+]] { }\n  StrategoLang-Type.DynT = StrategoLang-Dyn { }\n  StrategoLang-Type.StringT = \"string\" { }\n  StrategoLang-Type.IntT = \"int\" { }\n  StrategoLang-Type.RealT = \"real\" { }\n  StrategoLang-Type.BlobT = \"blob\" { }\n  StrategoLang-Type = [([StrategoLang-Type])] {bracket}\n  StrategoLang-Type = StrategoLang-SortT { }\n  StrategoLang-SortT.SortT = [[StrategoLang-Id]([{StrategoLang-Type \", \"}*])] { }\n  StrategoLang-SortT.SortTNoArgs = StrategoLang-UCID { }\n  StrategoLang-SortT = \"TP\" {reject}\n  StrategoLang-SortT.SortTVar = StrategoLang-SortVar { }\n  StrategoLang-SortArg.SATupleT = [[StrategoLang-Sort] * [{StrategoLang-Sort \" * \"}+]] { }\n  StrategoLang-SortArg.SADynT = StrategoLang-Dyn { }\n\ncontext-free priorities\n\n  StrategoLang-Type.TupleT &lt;0&gt;. &gt; StrategoLang-Type.TupleT,\n  {StrategoLang-Type \"*\"}+ = StrategoLang-Type { } &lt;0&gt;. &gt; StrategoLang-Type.TupleT,\n  {StrategoLang-Type \"*\"}+ = {StrategoLang-Type \"*\"}+ \"*\" StrategoLang-Type { } &lt;2&gt;. &gt; StrategoLang-Type.TupleT\n\nsorts StrategoLang-SType StrategoLang-SFunType StrategoLang-SSimpleFunType StrategoLang-FunTType\n\ncontext-free syntax\n\n  StrategoLang-SType.SDyn = [?] { }\n  StrategoLang-SType = StrategoLang-SFunType { }\n  StrategoLang-SSimpleFunType.TP = [TP] { }\n  StrategoLang-SSimpleFunType.FunNoArgsType = [[StrategoLang-Type] -&gt; [StrategoLang-Type]] { }\n  StrategoLang-SFunType = StrategoLang-SSimpleFunType { }\n  StrategoLang-SFunType.SFunType = [([{StrategoLang-SType \", \"}*]) [StrategoLang-SSimpleFunType]] { }\n  StrategoLang-SFunType = StrategoLang-FunTType { }\n  StrategoLang-FunTType.FunTType = [([{StrategoLang-SType \", \"}*] | [{StrategoLang-Type \", \"}*]) [StrategoLang-SSimpleFunType]] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/signatures-namespaced.sdf3/#modal-h2","title":"signatures-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/strategies-namespaced.sdf3/","title":"<code>strategies-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/strategies-namespaced\n\nimports\n  StrategoLang/gradual-types/signatures-namespaced        \n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/core/terms-namespaced\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\'\\-\\_]\n  tokenize : \")(|\"\n\nsorts StrategoLang-Coercion StrategoLang-SCoercion StrategoLang-Proxy\n\ncontext-free syntax\n\n  StrategoLang-Strategy.Cast = [cast([StrategoLang-Coercion])] { }\n  StrategoLang-Strategy.TypeTest = [is([StrategoLang-Type])] { }\n  StrategoLang-Coercion.FailC = [fail] { }\n  StrategoLang-Coercion.IdC = [id] { }\n  StrategoLang-Coercion.RuntimeCheck = StrategoLang-Type { }\n  StrategoLang-SCoercion.SFail = [fail] { }\n  StrategoLang-SCoercion.SId = [id] { }\n  StrategoLang-SCoercion.SRuntimeCheck = StrategoLang-SType { }\n  StrategoLang-Strategy = StrategoLang-Proxy { }\n  StrategoLang-Proxy.Proxy = [proxy([StrategoLang-Coercion], [StrategoLang-Coercion])([StrategoLang-SVar])] { }\n  StrategoLang-Proxy.ProxyT = [proxy([{StrategoLang-SCoercion \", \"}*] | [{StrategoLang-Coercion \", \"}*])([StrategoLang-Coercion], [StrategoLang-Coercion])([StrategoLang-SVar])] { }\n  StrategoLang-SVar = \"cast\" {reject}\n\nsorts StrategoLang-TypedSVar StrategoLang-TypedTVar\n\ncontext-free syntax\n\n  StrategoLang-StrategyDef.ExtTypedDef = [external [StrategoLang-MaybeEmptySId] :: [StrategoLang-FunTType]] { }\n  StrategoLang-StrategyDef.ExtTypedDefInl = [external [StrategoLang-MaybeEmptySId]([{StrategoLang-ID \", \"}*] | [{StrategoLang-ID \", \"}*]) :: [StrategoLang-FunTType] =\n  [StrategoLang-Strategy]] { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/strategies-namespaced.sdf3/#modal-h2","title":"strategies-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/terms-namespaced.sdf3/","title":"<code>terms-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/gradual-types/terms-namespaced\n\nimports\n  StrategoLang/core/terms-namespaced        \n  StrategoLang/sugar/terms-namespaced        \n  StrategoLang/gradual-types/signatures-namespaced\n\ncontext-free syntax\n\n  StrategoLang-Term.TypeAscription = [[StrategoLang-Term] :: [StrategoLang-Type]] { }\n\ncontext-free priorities\n\n  {StrategoLang-Term.App\n   StrategoLang-PreTerm.AppPT\n   StrategoLang-Term.BuildDefault} &gt; StrategoLang-Term.TypeAscription\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/gradual-types/terms-namespaced.sdf3/#modal-h2","title":"terms-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/constants-namespaced.sdf3/","title":"<code>constants-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/constants-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/constants-namespaced        \n  StrategoLang/sugar/string-quotations-namespaced\n\nsorts Char-LEX CharChar-LEX\n\nlexical syntax\n\n  StrategoLang-Char = \"'\" StrategoLang-CharChar \"'\" { }\n  StrategoLang-CharChar = ~[\\'\\\\\\n\\r] { }\n  StrategoLang-CharChar = [\\\\] [tnrbf\\\"\\'\\\\] { }\n  StrategoLang-Id = StrategoLang-Char {reject}\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/constants-namespaced.sdf3/#modal-h2","title":"constants-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/dynamic-rules-namespaced.sdf3/","title":"<code>dynamic-rules-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/dynamic-rules-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/terms-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/sugar/strategies-namespaced        \n  StrategoLang/sugar/rules-namespaced\n\ntemplate options\n\n  tokenize : \")(\"\n\nsorts StrategoLang-ScopeLabels\n\ncontext-free syntax\n\n  StrategoLang-Strategy.DynRuleScope = &lt;{| &lt;StrategoLang-ScopeLabels&gt;\n: &lt;StrategoLang-Strategy&gt;\n|}&gt; { }\n  StrategoLang-ScopeLabels = {StrategoLang-DynRuleScopeId \", \"}* { }\n  StrategoLang-ScopeLabels.ScopeLabels = &lt;~&lt;StrategoLang-Term&gt;&gt; { }\n\nsorts StrategoLang-DynRuleDef StrategoLang-DynRuleId StrategoLang-DynRuleScopeId\n\ncontext-free syntax\n\n  StrategoLang-Strategy.GenDynRules = &lt;rules(&lt;StrategoLang-DynRuleDef*&gt;)&gt; { }\n  StrategoLang-DynRuleDef.AddScopeLabel = &lt;&lt;StrategoLang-SId&gt; + &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleDef.UndefineDynRule = &lt;&lt;StrategoLang-DynRuleId&gt; :- &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleDef.SetDynRule = &lt;&lt;StrategoLang-DynRuleId&gt; : &lt;StrategoLang-Rule&gt;&gt; { }\n  StrategoLang-DynRuleDef.AddDynRule = &lt;&lt;StrategoLang-DynRuleId&gt; :+ &lt;StrategoLang-Rule&gt;&gt; { }\n  StrategoLang-DynRuleDef.SetDynRuleMatch = &lt;&lt;StrategoLang-DynRuleId&gt; : &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleDef.DynRuleAssign = &lt;&lt;StrategoLang-DynRuleId&gt; := &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleDef.DynRuleAssignAdd = &lt;&lt;StrategoLang-DynRuleId&gt; :+= &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleDef.SetDynRuleDepends = &lt;&lt;StrategoLang-DynRuleId&gt; : &lt;StrategoLang-Rule&gt; depends on &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleId.LabeledDynRuleId = &lt;&lt;StrategoLang-RuleDec&gt; . &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleId.AddLabelDynRuleId = &lt;&lt;StrategoLang-RuleDec&gt; + &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleId.DynRuleId = StrategoLang-RuleDec { }\n  StrategoLang-DynRuleScopeId.LabeledDynRuleScopeId = &lt;&lt;StrategoLang-Id&gt; . &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-DynRuleScopeId.DynRuleScopeId = StrategoLang-Id { }\n\nsorts StrategoLang-RuleDec\n\ncontext-free syntax\n\n  StrategoLang-RuleDec.RDecNoArgs = StrategoLang-SId { }\n  StrategoLang-RuleDec.RDec = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; )&gt; { }\n  StrategoLang-RuleDec.RDecT = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; | &lt;{StrategoLang-Typedid \", \"}*&gt;)&gt; { }\n\nsorts StrategoLang-RuleNames\n\ncontext-free syntax\n\n  StrategoLang-RuleNames = {StrategoLang-SId \", \"}* { }\n  StrategoLang-RuleNames.RuleNames = &lt;~&lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-Strategy.DynRuleIntersectFix = &lt;/&lt;StrategoLang-RuleNames&gt;\\\\* &lt;StrategoLang-Strategy&gt;&gt; { }\n\nsyntax\n\n  StrategoLang-Strategy-CF.DynRuleUnionFix = \"\\\\\" LAYOUT?-CF StrategoLang-RuleNames-CF \"/*\" LAYOUT?-CF StrategoLang-Strategy-CF { }\n  StrategoLang-Strategy-CF.DynRuleUnionFix1 = \"\\\\\" LAYOUT?-CF StrategoLang-RuleNames-CF \" /*\" LAYOUT?-CF StrategoLang-Strategy-CF { }\n  StrategoLang-Strategy-CF.DynRuleIntersectUnionFix = \"/\" LAYOUT?-CF StrategoLang-RuleNames-CF LAYOUT?-CF \"\\\\\" LAYOUT?-CF StrategoLang-RuleNames-CF \"/*\" LAYOUT?-CF StrategoLang-Strategy-CF { }\n  StrategoLang-Strategy-CF.DynRuleIntersectUnionFix1 = \"/\" LAYOUT?-CF StrategoLang-RuleNames-CF LAYOUT?-CF \"\\\\\" LAYOUT?-CF StrategoLang-RuleNames-CF \" /*\" LAYOUT?-CF StrategoLang-Strategy-CF { }\n\ncontext-free syntax\n\n  StrategoLang-Strategy.DynRuleIntersect = &lt;&lt;StrategoLang-Strategy&gt; /&lt;StrategoLang-RuleNames&gt;\\\\ &lt;StrategoLang-Strategy&gt;&gt; {right}\n  StrategoLang-Strategy.DynRuleUnion = &lt;&lt;StrategoLang-Strategy&gt; \\\\&lt;StrategoLang-RuleNames&gt;/ &lt;StrategoLang-Strategy&gt;&gt; {right}\n  StrategoLang-Strategy.DynRuleIntersectUnion = &lt;&lt;StrategoLang-Strategy&gt; /&lt;StrategoLang-RuleNames&gt;\\\\&lt;StrategoLang-RuleNames&gt;/ &lt;StrategoLang-Strategy&gt;&gt; {right}\n\ncontext-free priorities\n\n  StrategoLang-Strategy.BA &gt; {StrategoLang-Strategy.DynRuleIntersectFix\n                              StrategoLang-Strategy.DynRuleUnionFix} &gt; StrategoLang-Strategy.AM &gt; StrategoLang-Strategy.DynRuleIntersect &gt; StrategoLang-Strategy.DynRuleUnion &gt; StrategoLang-Strategy.DynRuleIntersectUnion &gt; StrategoLang-Strategy.Seq\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/dynamic-rules-namespaced.sdf3/#modal-h2","title":"dynamic-rules-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/main-namespaced.sdf3/","title":"<code>main-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/main-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/modules-namespaced        \n  StrategoLang/sugar/constants-namespaced        \n  StrategoLang/sugar/signatures-namespaced        \n  StrategoLang/sugar/modules-namespaced        \n  StrategoLang/sugar/terms-namespaced        \n  StrategoLang/sugar/strategies-namespaced        \n  StrategoLang/sugar/rules-namespaced        \n  StrategoLang/sugar/dynamic-rules-namespaced        \n  StrategoLang/sugar/overlays-namespaced\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/main-namespaced.sdf3/#modal-h2","title":"main-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/modules-namespaced.sdf3/","title":"<code>modules-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/modules-namespaced\n\nimports\n  StrategoLang/core/modules-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/sugar/overlays-namespaced        \n  StrategoLang/sugar/rules-namespaced\n\ncontext-free syntax\n\n  StrategoLang-Decl.Rules = &lt;rules\n  &lt;{StrategoLang-Def \"\\n\\n\"}*&gt;&gt; { }\n  StrategoLang-Decl.Overlays = &lt;overlays\n  &lt;{StrategoLang-Overlay \"\\n\\n\"}*&gt;&gt; { }\n  StrategoLang-Def = &lt;&lt;StrategoLang-RuleDef&gt;&gt; { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/modules-namespaced.sdf3/#modal-h2","title":"modules-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/overlays-namespaced.sdf3/","title":"<code>overlays-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/overlays-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/terms-namespaced\n\nsorts StrategoLang-Overlay\n\ncontext-free syntax\n\n  StrategoLang-Overlay.OverlayNoArgs = &lt;&lt;StrategoLang-Id&gt; = &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-Overlay.Overlay = &lt;&lt;StrategoLang-Id&gt;(&lt;{StrategoLang-Id \", \"}*&gt;) = &lt;StrategoLang-Term&gt;&gt; { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/overlays-namespaced.sdf3/#modal-h2","title":"overlays-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/rules-namespaced.sdf3/","title":"<code>rules-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/rules-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/core/terms-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/sugar/terms-namespaced        \n  StrategoLang/sugar/strategies-namespaced\n\ntemplate options\n\n  tokenize : \")(|\"\n\nsorts StrategoLang-RuleDef StrategoLang-RDefT StrategoLang-RDefP\n\ncontext-free syntax\n\n  StrategoLang-RuleDef.RDefNoArgs = &lt;&lt;StrategoLang-SId&gt;:\n  &lt;StrategoLang-Rule&gt;&gt; { }\n  StrategoLang-Def.AnnoRuleDef = &lt;&lt;StrategoLang-Anno+&gt; &lt;StrategoLang-RuleDef&gt;&gt; { }\n  StrategoLang-RuleDef.RDef = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt;):\n  &lt;StrategoLang-Rule&gt;&gt; { }\n  StrategoLang-RuleDef = StrategoLang-RDefT { }\n  StrategoLang-RDefT.RDefT = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; | &lt;{StrategoLang-Typedid \", \"}*&gt;):\n  &lt;StrategoLang-Rule&gt;&gt; { }\n  StrategoLang-RuleDef = StrategoLang-RDefP { }\n  StrategoLang-RDefP.RDefP = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt; | &lt;{StrategoLang-Term \", \"}+&gt;):\n  &lt;StrategoLang-Rule&gt;&gt; { }\n  StrategoLang-RDefP = StrategoLang-RDefT {reject}\n\nsorts StrategoLang-Rule StrategoLang-RuleCond\n\ncontext-free syntax\n\n  StrategoLang-Rule.Rule = [[StrategoLang-Term] -&gt; [StrategoLang-Term]\n  [{StrategoLang-RuleCond \"\\n\"}*]] { }\n  StrategoLang-RuleCond.WhereClause = &lt;where\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n  StrategoLang-RuleCond.WithClause = &lt;with\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/rules-namespaced.sdf3/#modal-h2","title":"rules-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/signatures-namespaced.sdf3/","title":"<code>signatures-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/signatures-namespaced\n\nimports\n  StrategoLang/core/signatures-namespaced        \n  StrategoLang/sugar/constants-namespaced        \n  StrategoLang/core/identifiers-namespaced\n\ncontext-free syntax\n\n  StrategoLang-Sort.SortList = &lt;[&lt;{StrategoLang-Sort \", \"}*&gt; ]&gt; {deprecated(\"This syntax never had real meaning and will be dropped\")}\n  StrategoLang-Sort.SortListTl = &lt;[&lt;{StrategoLang-Sort \", \"}*&gt; | &lt;StrategoLang-Sort&gt; ]&gt; {deprecated(\"This syntax never had real meaning and will be dropped\")}\n  StrategoLang-Sort.SortTuple = &lt;(&lt;{StrategoLang-Sort \", \"}*&gt; )&gt; {deprecated(\"This syntax is being replaced\")}\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/signatures-namespaced.sdf3/#modal-h2","title":"signatures-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/strategies-namespaced.sdf3/","title":"<code>strategies-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/strategies-namespaced\n\nimports\n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/core/constants-namespaced        \n  StrategoLang/core/strategies-namespaced        \n  StrategoLang/core/terms-namespaced        \n  StrategoLang/sugar/terms-namespaced        \n  StrategoLang/sugar/rules-namespaced        \n  StrategoLang/sugar/constants-namespaced        \n  StrategoLang/sugar/signatures-namespaced\n\ntemplate options\n\n  tokenize : \")(|\"\n\nsorts StrategoLang-SDefP\n\ncontext-free syntax\n\n  StrategoLang-StrategyDef.SDefNoArgs = &lt;&lt;StrategoLang-SId&gt; =\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n  StrategoLang-StrategyDef.SDef = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt;) =\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n  StrategoLang-StrategyDef = StrategoLang-SDefP { }\n  StrategoLang-SDefP.SDefP = &lt;&lt;StrategoLang-SId&gt;(&lt;{StrategoLang-Typedid \", \"}*&gt;|&lt;{StrategoLang-Term \",\"}+&gt;) =\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n  StrategoLang-SDefP = StrategoLang-SDefT {reject}\n\ncontext-free syntax\n\n  StrategoLang-Typedid.DefaultVarDec = StrategoLang-ID { }\n\nsorts StrategoLang-Call StrategoLang-With\n\ncontext-free syntax\n\n  StrategoLang-Strategy = StrategoLang-Call { }\n  StrategoLang-Call.Call = &lt;&lt;StrategoLang-SVar&gt;(&lt;{StrategoLang-Strategy \",\"}*&gt;)&gt; { }\n  StrategoLang-Call = StrategoLang-With {reject}\n  StrategoLang-Strategy.ScopeDefault = &lt;{&lt;StrategoLang-Strategy&gt;}&gt; { }\n  StrategoLang-Strategy.BA = [&lt;[StrategoLang-Strategy]&gt; [StrategoLang-Term]] { }\n  StrategoLang-Strategy.LChoice = [[StrategoLang-Strategy] &lt;+ [StrategoLang-Strategy]] {right}\n  StrategoLang-Strategy.Rec = &lt;rec &lt;StrategoLang-SId&gt;( &lt;StrategoLang-Strategy&gt; )&gt; { }\n  StrategoLang-Strategy.Not = &lt;not(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-Strategy.Where = &lt;where(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-Strategy = StrategoLang-With { }\n  StrategoLang-With.With = &lt;with(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-Strategy.Test = &lt;test(&lt;StrategoLang-Strategy&gt;)&gt; {deprecated(\"Use `where` instead\")}\n  StrategoLang-Strategy.PrimNoArgs = &lt;prim(&lt;StrategoLang-String&gt;)&gt; { }\n  StrategoLang-Strategy.Prim = &lt;prim(&lt;StrategoLang-String&gt;, &lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n\ncontext-free syntax\n\n  StrategoLang-Strategy.StrCong = &lt;&lt;StrategoLang-String&gt;&gt; { }\n  StrategoLang-Strategy.IntCong = &lt;&lt;StrategoLang-Int&gt;&gt; { }\n  StrategoLang-Strategy.RealCong = &lt;&lt;StrategoLang-Real&gt;&gt; { }\n  StrategoLang-Strategy.CharCong = &lt;&lt;StrategoLang-Char&gt;&gt; { }\n  StrategoLang-Strategy.CongQ = &lt;&lt;StrategoLang-String&gt;(&lt;{StrategoLang-Strategy \", \"}*&gt;)&gt; { }\n  StrategoLang-Strategy.EmptyTupleCong = &lt;( )&gt; { }\n  StrategoLang-Strategy = &lt;(&lt;StrategoLang-Strategy&gt;)&gt; {bracket}\n  StrategoLang-Strategy.TupleCong = &lt;(&lt;StrategoLang-Strategy&gt;, &lt;{StrategoLang-Strategy \", \"}+&gt; )&gt; { }\n  StrategoLang-Strategy.ListCongNoTail = &lt;[&lt;{StrategoLang-Strategy \", \"}*&gt; ]&gt; { }\n  StrategoLang-Strategy.ListCong = &lt;[&lt;{StrategoLang-Strategy \", \"}*&gt; | &lt;StrategoLang-Strategy&gt; ]&gt; { }\n  StrategoLang-Strategy.ExplodeCong = &lt;&lt;StrategoLang-Strategy&gt;#(&lt;StrategoLang-Strategy&gt;)&gt; { }\n  StrategoLang-Strategy.AM = [[StrategoLang-Strategy] =&gt; [StrategoLang-Term]] { }\n  StrategoLang-Strategy.Assign = &lt;&lt;StrategoLang-Term&gt; := &lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-Strategy.AnnoCong = &lt;&lt;StrategoLang-Strategy&gt;{&lt;StrategoLang-Strategy&gt;}&gt; { }\n\ncontext-free syntax\n\n  StrategoLang-Strategy.CallNoArgs = &lt;&lt;StrategoLang-SVar&gt;&gt; { }\n  StrategoLang-Strategy.LRule = &lt;\\\\&lt;StrategoLang-Rule&gt;\\\\&gt; { }\n  StrategoLang-Strategy.SRule = &lt;(&lt;StrategoLang-Rule&gt;)&gt; { }\n  StrategoLang-Strategy.Choice = &lt;&lt;StrategoLang-Strategy&gt; + &lt;StrategoLang-Strategy&gt;&gt; {right}\n  StrategoLang-Strategy.RChoice = [[StrategoLang-Strategy] +&gt; [StrategoLang-Strategy]] {right, deprecated(\"Flip your arguments and use &lt;+\")}\n  StrategoLang-Strategy.Proceed = &lt;proceed(&lt;{StrategoLang-Strategy \", \"}+&gt;)&gt; { }\n  StrategoLang-Strategy.CondChoice = &lt;if &lt;StrategoLang-Strategy&gt; then &lt;StrategoLang-Strategy&gt; else &lt;StrategoLang-Strategy&gt; end&gt; { }\n  StrategoLang-Strategy.IfThen = &lt;if &lt;StrategoLang-Strategy&gt; then &lt;StrategoLang-Strategy&gt; end&gt; { }\n  StrategoLang-Strategy.LTrySome = [[StrategoLang-Strategy] &lt;* [StrategoLang-Strategy]] {left}\n\nsorts StrategoLang-SwitchCase\n\ncontext-free syntax\n\n  StrategoLang-Strategy.SwitchChoiceNoOtherwise = &lt;switch &lt;StrategoLang-Strategy&gt;\n  &lt;{StrategoLang-SwitchCase \"\\n\"}*&gt;\nend&gt; { }\n  StrategoLang-Strategy.SwitchChoice = &lt;switch &lt;StrategoLang-Strategy&gt;\n  &lt;{StrategoLang-SwitchCase \"\\n\"}*&gt;\n  otherwise : &lt;StrategoLang-Strategy&gt;\nend&gt; { }\n  StrategoLang-SwitchCase.SwitchCase = &lt;case &lt;StrategoLang-Strategy&gt;:\n  &lt;StrategoLang-Strategy&gt;&gt; { }\n\ncontext-free priorities\n\n  {StrategoLang-Strategy.AnnoCong\n   StrategoLang-Strategy.ExplodeCong} &gt; {StrategoLang-Strategy.Match\n                                         StrategoLang-Strategy.Build} &gt; StrategoLang-Strategy.BA &gt; StrategoLang-Strategy.AM &gt; StrategoLang-Strategy.Seq &gt; StrategoLang-Strategy.LTrySome &gt; {right :\n    StrategoLang-Strategy.Choice\n    StrategoLang-Strategy.LChoice\n    StrategoLang-Strategy.RChoice\n    StrategoLang-Strategy.GuardedLChoice}\n\ncontext-free priorities\n\n  StrategoLang-Strategy.AnnoCong &lt;0&gt;. &gt; {StrategoLang-Strategy.Match\n                                         StrategoLang-Strategy.Build\n                                         StrategoLang-Strategy.Assign\n                                         StrategoLang-Strategy.BA\n                                         StrategoLang-Strategy.AM},\n  StrategoLang-Strategy.ExplodeCong &lt;0&gt;. &gt; {StrategoLang-Strategy.Match\n                                            StrategoLang-Strategy.Build\n                                            StrategoLang-Strategy.Assign\n                                            StrategoLang-Strategy.BA\n                                            StrategoLang-Strategy.AM}\n\ncontext-free priorities\n\n  StrategoLang-Strategy.GuardedLChoice &lt;2&gt;. &gt; StrategoLang-Strategy.Choice\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/strategies-namespaced.sdf3/#modal-h2","title":"strategies-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/string-quotations-namespaced.sdf3/","title":"<code>string-quotations-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/string-quotations-namespaced\n\nimports\n  StrategoLang/core/terms-namespaced\n\nsorts StrategoLang-StringQuotation StrategoLang-StringQuotedPart1 StrategoLang-StringQuotedPart2 StrategoLang-StringQuotedPart3 StrategoLang-StringQuotedPart4\n\ncontext-free syntax\n\n  StrategoLang-PreTerm = StrategoLang-StringQuotation { }\n  StrategoLang-StringQuotedPart1.QStr1 = StrategoLang-StringQuotedChars1 { }\n  StrategoLang-StringQuotedPart2.QStr2 = StrategoLang-StringQuotedChars2 { }\n  StrategoLang-StringQuotedPart3.QStr3 = StrategoLang-StringQuotedChars3 { }\n  StrategoLang-StringQuotedPart4.QStr4 = StrategoLang-StringQuotedChars4 { }\n  StrategoLang-StringQuotedPart1.QDollar1 = StrategoLang-Dollar1 { }\n  StrategoLang-StringQuotedPart2.QDollar2 = StrategoLang-Dollar2 { }\n  StrategoLang-StringQuotedPart3.QDollar3 = StrategoLang-Dollar3 { }\n  StrategoLang-StringQuotedPart4.QDollar4 = StrategoLang-Dollar4 { }\n  StrategoLang-StringQuotedPart1.QBr1 = StrategoLang-QuotedBracket1 { }\n  StrategoLang-StringQuotedPart2.QBr2 = StrategoLang-QuotedBracket2 { }\n  StrategoLang-StringQuotedPart3.QBr3 = StrategoLang-QuotedBracket3 { }\n  StrategoLang-StringQuotedPart4.QBr4 = StrategoLang-QuotedBracket4 { }\n\nsorts StringQuotedChars1-LEX Dollar1-LEX QuotedBracket1-LEX StringQuotedChars2-LEX Dollar2-LEX QuotedBracket2-LEX StringQuotedChars3-LEX Dollar3-LEX QuotedBracket3-LEX StringQuotedChars4-LEX Dollar4-LEX QuotedBracket4-LEX\n\nlexical syntax\n\n  StrategoLang-StringQuotedChars1 = ~[\\[\\]\\$]+ { }\n  StrategoLang-StringQuotedChars2 = ~[\\{\\}\\$]+ { }\n  StrategoLang-StringQuotedChars3 = ~[\\(\\)\\$]+ { }\n  StrategoLang-StringQuotedChars4 = ~[\\&lt;\\&gt;\\$]+ { }\n  StrategoLang-Dollar1 = \"$\" { }\n  StrategoLang-Dollar2 = \"$\" { }\n  StrategoLang-Dollar3 = \"$\" { }\n  StrategoLang-Dollar4 = \"$\" { }\n  StrategoLang-QuotedBracket1 = \"$\" [\\[\\]] \"$\" { }\n  StrategoLang-QuotedBracket2 = \"$\" [\\{\\}] \"$\" { }\n  StrategoLang-QuotedBracket3 = \"$\" [\\(\\)] \"$\" { }\n  StrategoLang-QuotedBracket4 = \"$\" [\\&lt;\\&gt;] \"$\" { }\n\nlexical restrictions\n\n  StrategoLang-StringQuotedChars1 -/- ~[\\[\\]\\$]\n  StrategoLang-StringQuotedChars2 -/- ~[\\{\\}\\$]\n  StrategoLang-StringQuotedChars3 -/- ~[\\(\\)\\$]\n  StrategoLang-StringQuotedChars4 -/- ~[\\&lt;\\&gt;\\$]\n  StrategoLang-Dollar1 -/- [\\[\\]].[\\$]\n  StrategoLang-Dollar2 -/- [\\{\\}].[\\$]\n  StrategoLang-Dollar3 -/- [\\(\\)].[\\$]\n  StrategoLang-Dollar4 -/- [\\&lt;\\&gt;].[\\$]\n\nsyntax\n\n  StrategoLang-StringQuotation-CF.StringQuotation1 = \"$\" \"[\" StrategoLang-StringQuotedPart1-CF* \"]\" { }\n  StrategoLang-StringQuotation-CF.StringQuotation2 = \"$\" \"{\" StrategoLang-StringQuotedPart2-CF* \"}\" { }\n  StrategoLang-StringQuotation-CF.StringQuotation3 = \"$\" \"(\" StrategoLang-StringQuotedPart3-CF* \")\" { }\n  StrategoLang-StringQuotation-CF.StringQuotation4 = \"$\" \"&lt;\" StrategoLang-StringQuotedPart4-CF* \"&gt;\" { }\n  StrategoLang-StringQuotedPart1-CF.StringEscape1 = \"[\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \"]\" { }\n  StrategoLang-StringQuotedPart2-CF.StringEscape2 = \"{\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \"}\" { }\n  StrategoLang-StringQuotedPart3-CF.StringEscape3 = \"(\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \")\" { }\n  StrategoLang-StringQuotedPart4-CF.StringEscape4 = \"&lt;\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \"&gt;\" { }\n\nsorts StrategoLang-InternalStringQuotation StrategoLang-InternalStringQuotedPart1 StrategoLang-InternalStringQuotedPart2 StrategoLang-InternalStringQuotedPart3 StrategoLang-InternalStringQuotedPart4\n\nsyntax\n\n  StrategoLang-InternalStringQuotation-CF.StringQuotation1 = \"$\" \"[\" StrategoLang-Padding-LEX StrategoLang-InternalStringQuotedPart1-CF* \"]\" { }\n  StrategoLang-InternalStringQuotation-CF.StringQuotation2 = \"$\" \"{\" StrategoLang-Padding-LEX StrategoLang-InternalStringQuotedPart2-CF* \"}\" { }\n  StrategoLang-InternalStringQuotation-CF.StringQuotation3 = \"$\" \"(\" StrategoLang-Padding-LEX StrategoLang-InternalStringQuotedPart3-CF* \")\" { }\n  StrategoLang-InternalStringQuotation-CF.StringQuotation4 = \"$\" \"&lt;\" StrategoLang-Padding-LEX StrategoLang-InternalStringQuotedPart4-CF* \"&gt;\" { }\n  StrategoLang-InternalStringQuotedPart1-CF.StringEscape1 = StrategoLang-Padding-LEX \"[\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \"]\" { }\n  StrategoLang-InternalStringQuotedPart2-CF.StringEscape2 = StrategoLang-Padding-LEX \"{\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \"}\" { }\n  StrategoLang-InternalStringQuotedPart3-CF.StringEscape3 = StrategoLang-Padding-LEX \"(\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \")\" { }\n  StrategoLang-InternalStringQuotedPart4-CF.StringEscape4 = StrategoLang-Padding-LEX \"&lt;\" LAYOUT?-CF StrategoLang-Term-CF LAYOUT?-CF \"&gt;\" { }\n\nsorts Padding-LEX\n\nlexical syntax\n\n  StrategoLang-Padding = ' '+ { }\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/string-quotations-namespaced.sdf3/#modal-h2","title":"string-quotations-namespaced.sdf3","text":""},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/terms-namespaced.sdf3/","title":"<code>terms-namespaced.sdf3</code>","text":"<pre><code>module StrategoLang/sugar/terms-namespaced\n\nimports\n  StrategoLang/core/terms-namespaced        \n  StrategoLang/core/identifiers-namespaced        \n  StrategoLang/sugar/constants-namespaced        \n  StrategoLang/sugar/strategies-namespaced\n\ncontext-free syntax\n\n  StrategoLang-ID.ListVar = StrategoLang-LId { }\n\ncontext-free syntax\n\n  StrategoLang-Term.BuildDefault = &lt;_&lt;StrategoLang-Term&gt;&gt; { }\n  StrategoLang-Term.AnnoList = &lt;&lt;StrategoLang-PreTerm&gt;{&lt;{StrategoLang-Term \", \"}*&gt;}&gt; { }\n  StrategoLang-Term.NoAnnoList = StrategoLang-PreTerm { }\n  StrategoLang-Term.App = [&lt;[StrategoLang-Strategy]&gt; [StrategoLang-Term]] { }\n  StrategoLang-Term.RootApp = [&lt;[StrategoLang-Strategy]&gt;] { }\n\ncontext-free syntax\n\n  StrategoLang-PreTerm.Char = StrategoLang-Char { }\n  StrategoLang-PreTerm.AppPT = [&lt;[StrategoLang-Strategy]&gt; [StrategoLang-Term]] { }\n  StrategoLang-PreTerm.RootAppPT = [&lt;[StrategoLang-Strategy]&gt;] { }\n  StrategoLang-PreTerm.Tuple = &lt;(&lt;{StrategoLang-Term \", \"}*&gt;)&gt; { }\n  StrategoLang-PreTerm.List = &lt;[&lt;{StrategoLang-Term \", \"}*&gt;]&gt; { }\n  StrategoLang-PreTerm.ListTail = &lt;[&lt;{StrategoLang-Term \", \"}+&gt; | &lt;StrategoLang-Term&gt;]&gt; { }\n  StrategoLang-PreTerm.BuildDefaultPT = &lt;_&lt;StrategoLang-PreTerm&gt;&gt; { }\n\ncontext-free priorities\n\n  StrategoLang-Term.NoAnnoList = StrategoLang-PreTerm { } &lt;0&gt;. &gt; {StrategoLang-PreTerm = StrategoLang-Var { }\n                                                                  StrategoLang-PreTerm = StrategoLang-Wld { }},\n  StrategoLang-Term.NoAnnoList &lt;0&gt;. &gt; {StrategoLang-PreTerm.AsPT\n                                       StrategoLang-PreTerm.AppPT\n                                       StrategoLang-PreTerm.RootAppPT\n                                       StrategoLang-PreTerm.BuildDefaultPT},\n  StrategoLang-Term.AnnoList &gt; {StrategoLang-PreTerm.AsPT\n                                StrategoLang-PreTerm.AppPT},\n  StrategoLang-Term.Anno &gt; StrategoLang-PreTerm.AppPT,\n  StrategoLang-PreTerm.Explode &gt; {StrategoLang-Term.App\n                                  StrategoLang-PreTerm.AppPT\n                                  StrategoLang-Term.BuildDefault\n                                  StrategoLang-PreTerm.BuildDefaultPT}\n\n</code></pre> \u00d7"},{"location":"stratego.lang/src-gen/syntax/StrategoLang/sugar/terms-namespaced.sdf3/#modal-h2","title":"terms-namespaced.sdf3","text":""},{"location":"stratego.lang/syntax/StrategoLang.sdf3/","title":"<code>StrategoLang.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/StrategoLang.sdf3</p> <pre><code>module StrategoLang\n\nimports\n  import\n  core/modules // for the Module sort\n\ncontext-free start-symbols Module\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/StrategoLang.sdf3/#modal-h2","title":"StrategoLang.sdf3","text":""},{"location":"stratego.lang/syntax/deduplicated.sdf3/","title":"<code>deduplicated.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/deduplicated.sdf3</p> <pre><code>module deduplicated\n\nimports\n  core/terms\n  core/signatures\n  core/identifiers\n\n  sugar/terms\n  sugar/rules\n  core/strategies\n  sugar/dynamic-rules\n  sugar/string-quotations\n\n  gradual-types/signatures\n  gradual-types/strategies\n\n/*\nThis file contains the original productions of constructors that were renamed to conform to\nrequirements from Statix that every constructor be unique.\n*/\n\ncontext-free syntax // core/terms\n  PreTerm.As      = &lt;&lt;Var&gt;@&lt;PreTerm&gt;&gt;\n\ncontext-free syntax // core/signatures\n  SortDef.SortVar    = LCID {deprecated(\"This syntax never had a clear meaning should not be used\")}\n  SortDef.SortNoArgs = UCID\n  SortDef.Sort = [[UCID]([{Kind \", \"}*])]\n  SortDef.Sort = &lt;&lt;Id&gt;(&lt;{Sort \", \"}+&gt;)&gt; {deprecated(\"This syntax never had a clear meaning should be replaced by the version that uses kinds A(*, *)\")}\n\n  SortDef.ExtSort = [external [UCID]([{Kind \", \"}*])]\n\n  OpType.FunType = [[{ConstType \" * \"}+] -&gt; [ConstType]]\n\ncontext-free syntax // sugar/terms\n  PreTerm.App       = [&lt;[Strategy]&gt; [Term]]\n  PreTerm.RootApp   = [&lt;[Strategy]&gt;]\n\ncontext-free syntax // sugar/rules\n  Def.AnnoDef =\n    &lt;&lt;Anno+&gt; &lt;RuleDef&gt;&gt;\n\nsyntax // sugar/dynamic-rules\n  // 1 space after RuleNames\n  Strategy-CF.DynRuleUnionFix =\n  \"\\\\\" LAYOUT?-CF RuleNames-CF \" /*\" LAYOUT?-CF Strategy-CF\n\n  // 1 space after RuleNames\n  Strategy-CF.DynRuleIntersectUnionFix =\n  \"/\" LAYOUT?-CF RuleNames-CF LAYOUT?-CF \"\\\\\"\n      LAYOUT?-CF RuleNames-CF \" /*\" LAYOUT?-CF Strategy-CF\n\ncontext-free syntax // sugar/string-quotations\n\n  StringQuotedPart1.QStr = StringQuotedChars1\n  StringQuotedPart2.QStr = StringQuotedChars2\n  StringQuotedPart3.QStr = StringQuotedChars3\n  StringQuotedPart4.QStr = StringQuotedChars4\n\n  StringQuotedPart1.QDollar = Dollar1\n  StringQuotedPart2.QDollar = Dollar2\n  StringQuotedPart3.QDollar = Dollar3\n  StringQuotedPart4.QDollar = Dollar4\n\n  StringQuotedPart1.QBr = QuotedBracket1\n  StringQuotedPart2.QBr = QuotedBracket2\n  StringQuotedPart3.QBr = QuotedBracket3\n  StringQuotedPart4.QBr = QuotedBracket4\n\ncontext-free syntax // gradual-types/signatures\n  ConstType.DynT = Dyn\n\n  SortT.Sort       = [[Id]([{Type \", \"}*])]\n  SortT.SortNoArgs = UCID\n  SortT.SortVar    = SortVar\n\n  SortArg.TupleT = [[Sort] * [{Sort \" * \"}+]]\n  SortArg.DynT   = Dyn\n\n  SFunType.FunType = [([{SType \", \"}*]) [SSimpleFunType]]\n\ncontext-free syntax // gradual-types/strategies\n  Coercion.Fail = [fail]\n  Coercion.Id = [id]\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/deduplicated.sdf3/#modal-h2","title":"deduplicated.sdf3","text":""},{"location":"stratego.lang/syntax/import.sdf3/","title":"<code>import.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/import.sdf3</p> <pre><code>module import\n\nimports\n  sugar/main\n  core/main\n  gradual-types/main\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/import.sdf3/#modal-h2","title":"import.sdf3","text":""},{"location":"stratego.lang/syntax/core/constants.sdf3/","title":"<code>constants.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/constants.sdf3</p> <pre><code>module core/constants\n\nlexical sorts Int Real String StrChar\nlexical syntax\n  Int     = [\\-]? [0-9]+\n\n  Real    = [\\-]? [0-9]+ [\\.] [0-9]+\n\n  String  = \"\\\"\" StrChar* \"\\\"\"\n\n  StrChar = ~[\\\"\\\\]\n  StrChar = [\\\\] [tnrbf\\\"\\'\\\\]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/constants.sdf3/#modal-h2","title":"constants.sdf3","text":""},{"location":"stratego.lang/syntax/core/identifiers.sdf3/","title":"<code>identifiers.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/identifiers.sdf3</p> <pre><code>module core/identifiers\n\nlexical sorts ModName ModNamePart\nlexical syntax\n  ModName = {ModNamePart \"/\"}+\n  ModNamePart = [a-zA-Z\\.\\_] [a-zA-Z0-9\\'\\.\\-\\_]*\nlexical restrictions\n  ModName -/- [a-zA-Z0-9\\'\\.\\-\\_]\ncontext-free syntax\n  ModName = \"imports\"     {reject}\n  ModName = \"overlays\"    {reject}\n  ModName = \"rules\"       {reject}\n  ModName = \"signature\"   {reject}\n  ModName = \"strategies\"  {reject}\n\nlexical sorts Id LId LCID UCID SortVar BuiltInType SomeSort\nlexical syntax\n// Removed leading underscore option, nearly always conflicts with Term.BuildDefault\n//  Id   = [a-zA-Z\\_] [a-zA-Z0-9\\'\\-\\_]*\n//  LId  = [a-zA-Z\\_] [a-zA-Z0-9\\'\\-\\_]* \"*\"\n  Id   = [a-zA-Z] [a-zA-Z0-9\\'\\-\\_]*\n  LId  = [a-zA-Z] [a-zA-Z0-9\\'\\-\\_]* \"*\"\n  Id   = [\\'] [a-z]+\n\n  LCID = [a-z] [a-zA-Z0-9\\'\\-\\_]*\n  UCID = [A-Z] [a-zA-Z0-9\\'\\-\\_]*\n\n  SortVar = LCID\n  SortVar = BuiltInType {reject}\n  BuiltInType = \"string\"\n  BuiltInType = \"int\"\n  BuiltInType = \"real\"\n  BuiltInType = \"blob\"\n\nlexical restrictions\n  Id   -/- [a-zA-Z0-9\\'\\_\\*]\n  Id   -/- [\\-].~[\\&gt;]\n  LId  -/- [a-zA-Z0-9\\'\\-\\_]\n  LCID -/- [a-zA-Z0-9\\'\\-\\_]\n  UCID -/- [a-zA-Z0-9\\'\\-\\_]\n\nlexical syntax\n  Id   = \"_\"      {reject}\n  Id   = \"'\"      {reject}\n  Id   = Keyword  {reject}\n  Lid  = Keyword  {reject}\n  LCID = Keyword  {reject}\n  UCID = Keyword  {reject}\n\nlexical sorts Keyword\nlexical syntax\n  Keyword = \"all\"\n  Keyword = \"constructors\"\n  Keyword = \"fail\"\n  Keyword = \"id\"\n  Keyword = \"in\"\n  Keyword = \"let\"\n  Keyword = \"module\"\n  Keyword = \"not\"\n  Keyword = \"one\"\n  Keyword = \"overlays\"\n  Keyword = \"prim\"\n  Keyword = \"proceed\"\n  Keyword = \"rules\"\n  Keyword = \"script\"\n  Keyword = \"signature\"\n  Keyword = \"some\"\n  Keyword = \"sorts\"\n  Keyword = \"strategies\"\n  Keyword = \"stratego\"\n  Keyword = \"test\"\n  Keyword = \"where\"\n//  Keyword = \"with\"\n  Keyword = \"import-term\"\n  Keyword = \"is\"\n\nlexical restrictions\n  \"all\"\n  \"case\"          // not reserved kw\n  \"constructors\"\n  \"else\"          // not reserved kw\n  \"end\"           // not reserved kw\n  \"external\"      // not reserved kw\n  \"fail\"\n  \"id\"\n  \"if\"            // not reserved kw\n  \"in\"\n  \"is\"\n  \"imports\"       // not reserved kw\n  \"let\"\n  \"module\"\n  \"not\"\n  \"one\"\n  \"overlays\"\n  \"otherwise\"     // not reserved kw\n  \"prim\"\n  \"proceed\"\n  \"rec\"           // not reserved kw\n  \"rules\"\n  \"script\"\n  \"signature\"\n  \"some\"\n  \"sorts\"\n  \"strategies\"\n  \"stratego\"\n  \"switch\"        // not reserved kw\n  \"test\"\n  \"then\"          // not reserved kw\n  \"where\"\n  \"with\"\n  \"import-term\"\n    -/- [a-zA-Z0-9\\'\\-\\_]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/identifiers.sdf3/#modal-h2","title":"identifiers.sdf3","text":""},{"location":"stratego.lang/syntax/core/layout.sdf3/","title":"<code>layout.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/layout.sdf3</p> <pre><code>module core/layout\n\nlexical sorts Ws ShortCom LongCom CommChar Asterisk Eof\nlexical syntax\n  Ws       = [\\t\\ \\n\\r]\n  ShortCom = \"//\" ~[\\n\\r]* ([\\n\\r] | Eof)\n  LongCom  = \"/*\" CommChar* \"*/\"\n  Eof      =\n  CommChar = ~[\\*]\n  Asterisk = \"*\"\n  CommChar = Asterisk \n\nlexical restrictions\n  Asterisk -/- [\\/]\n  Eof      -/- ~[]\n\nlexical syntax\n  LAYOUT = ShortCom\n  LAYOUT = LongCom\n  LAYOUT = Ws\n\ncontext-free restrictions\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\*]\n  LAYOUT? -/- [\\/].[\\/]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/layout.sdf3/#modal-h2","title":"layout.sdf3","text":""},{"location":"stratego.lang/syntax/core/main.sdf3/","title":"<code>main.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/main.sdf3</p> <pre><code>module core/main\n\nimports\n  core/constants\n  core/identifiers\n  core/layout\n  core/signatures\n  core/terms\n  core/strategies\n  core/modules\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/main.sdf3/#modal-h2","title":"main.sdf3","text":""},{"location":"stratego.lang/syntax/core/modules.sdf3/","title":"<code>modules.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/modules.sdf3</p> <pre><code>module core/modules\n\nimports\n  core/identifiers\n  core/layout\n  core/signatures\n  core/strategies\n\ncontext-free sorts Module\ncontext-free syntax\n\n  Module.Module =\n&lt;module &lt;ModName&gt;\n\n&lt;{AnnoDecl \"\\n\\n\"}*&gt;&gt;\n\n  Module.Specification =\n&lt;specification\n\n&lt;{AnnoDecl \"\\n\\n\"}*&gt;&gt;\n\ncontext-free sorts Decl AnnoDecl\ncontext-free syntax\n  Decl.Imports =\n&lt;imports\n\n&lt;{ImportModName \"\\n\"}*&gt;&gt;\n\n  Decl.Strategies = \n&lt;strategies\n\n&lt;{Def \"\\n\\n\"}*&gt;&gt;\n\n  Decl.Signature =\n&lt;signature\n&lt;{Sdecl \"\\n\\n\"}*&gt;&gt;\n\n  AnnoDecl = Decl\n\ncontext-free sorts ImportModName\ncontext-free syntax\n  ImportModName.Import = ModName\n\nsyntax\n  ImportModName-CF.ImportWildcard = ModName-CF \"/\" \"-\"\n\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/modules.sdf3/#modal-h2","title":"modules.sdf3","text":""},{"location":"stratego.lang/syntax/core/signatures.sdf3/","title":"<code>signatures.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/signatures.sdf3</p> <pre><code>module core/signatures\n\nimports\n  core/identifiers\n  core/constants\n\ncontext-free sorts Kind\ncontext-free syntax\n  Kind.Star = &lt;*&gt;\n\ncontext-free sorts SortDef\ncontext-free syntax\n  SortDef.SortDefVar    = LCID {deprecated(\"This syntax never had a clear meaning should not be used\")}\n  SortDef.SortDefNoArgs = UCID\n  SortDef.SortDef = [[UCID]([{Kind \", \"}*])]\n  SortDef.SortDefDepr = &lt;&lt;Id&gt;(&lt;{Sort \", \"}+&gt;)&gt; {deprecated(\"This syntax never had a clear meaning should be replaced by the version that uses kinds A(*, *)\")}\n\n  SortDef.ExtSortDef = [external [UCID]([{Kind \", \"}*])]\n\ncontext-free sorts Sdecl\ncontext-free syntax\n\n  Sdecl.Sorts =\n&lt;sorts &lt;SortDef*&gt;&gt;\n\n  Sdecl.Constructors =\n&lt;constructors\n\n&lt;{Opdecl \"\\n\"}*&gt;&gt;\n\ncontext-free sorts Sort SortArg\ncontext-free syntax\n  Sort.SortVar    = LCID\n  Sort.SortNoArgs = UCID\n  Sort.Sort       = &lt;&lt;Id&gt;(&lt;{SortArg \", \"}*&gt;)&gt;\n  SortArg = Sort\n\ncontext-free sorts Opdecl\ncontext-free syntax\n  Opdecl.OpDecl    = &lt;&lt;Id&gt; : &lt;OpType&gt;&gt;\n  Opdecl.OpDeclQ   = &lt;&lt;String&gt; : &lt;OpType&gt;&gt;\n  Opdecl.OpDeclInj = &lt;: &lt;OpType&gt;&gt;\n\n  Opdecl.ExtOpDecl    = &lt;external &lt;Id&gt; : &lt;OpType&gt;&gt;\n  Opdecl.ExtOpDeclQ   = &lt;external &lt;String&gt; : &lt;OpType&gt;&gt;\n  Opdecl.ExtOpDeclInj = &lt;external : &lt;OpType&gt;&gt;\n\ncontext-free sorts OldType OldArgType ConstType FunType RetType OpType\ncontext-free syntax\n  ConstType.ConstType = Sort\n\n  FunType.FunType = [[{OldArgType \" * \"}+] -&gt; [RetType]]\n\n  OldArgType = &lt;(&lt;OldType&gt;)&gt; {bracket}\n  OldArgType = ConstType\n  RetType = OldType\n  RetType = FunType {reject}\n\n  OldType = FunType\n  OldType = ConstType\n\n  OpType = ConstType\n  OpType.OpFunType = [[{ConstType \" * \"}+] -&gt; [ConstType]]\n\n// Restriction is required for the Sort* in Sdecl: List(a) is ambiguous.\ncontext-free restrictions\n  Sort -/- [\\(]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/signatures.sdf3/#modal-h2","title":"signatures.sdf3","text":""},{"location":"stratego.lang/syntax/core/strategies.sdf3/","title":"<code>strategies.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/strategies.sdf3</p> <pre><code>module core/strategies\n\nimports\n  core/terms\n  core/constants\n  core/signatures\n  core/identifiers\n\ntemplate options\n  keyword -/- [a-zA-Z0-9\\'\\-\\_]\n  tokenize: \")(|\"\n\ncontext-free sorts Def\ncontext-free syntax\n  Def = StrategyDef\n\ncontext-free sorts StrategyDef SDefT\ncontext-free syntax\n  // indirection for SDefP in sugar/strategies\n  StrategyDef = SDefT\n  SDefT.SDefT =\n&lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt; | &lt;{Typedid \", \"}*&gt;) =\n  &lt;Strategy&gt;&gt;\n\n  Def.AnnoDef = &lt;&lt;Anno+&gt; &lt;StrategyDef&gt;&gt;\n\n  StrategyDef.ExtSDefInl =\n&lt;external &lt;SId&gt;(&lt;{Typedid \", \"}*&gt; | &lt;{Typedid \", \"}*&gt;) =\n  &lt;Strategy&gt;&gt;\n\n  StrategyDef.ExtSDef =\n    &lt;external &lt;MaybeEmptySId&gt;(&lt;{Typedid \", \"}*&gt; | &lt;{Typedid \", \"}*&gt;)&gt;\n\nlexical sorts SId MaybeEmptySId\nlexical syntax\n  // indirection for highlighting\n  SId = Id\n\n  MaybeEmptySId =\n  MaybeEmptySId = SId\n\ncontext-free sorts Anno\ncontext-free syntax\n  Anno.Extend = &lt;extend&gt;\n  Anno.Override = &lt;override&gt;\n  Anno.Internal = &lt;internal&gt;\n\ncontext-free sorts Typedid\ncontext-free syntax\n  Typedid.VarDec = &lt;&lt;ID&gt; : &lt;OldType&gt;&gt;\n\n\ncontext-free sorts Strategy SVar\ncontext-free syntax\n  Strategy.Fail  = &lt;fail&gt;\n  Strategy.Id    = &lt;id&gt;\n  Strategy.ProceedT = &lt;proceed(&lt;{Strategy \", \"}*&gt;|&lt;{Term \", \"}*&gt;)&gt;\n  Strategy.ProceedNoArgs = &lt;proceed&gt;\n  Strategy.Match = &lt;?&lt;Term&gt;&gt;\n  Strategy.Build = &lt;!&lt;Term&gt;&gt;\n  Strategy.Scope = &lt;{&lt;{ID \", \"}*&gt;: &lt;Strategy&gt; }&gt;\n  Strategy.Seq   = &lt;&lt;Strategy&gt;; &lt;Strategy&gt;&gt; {right}\n  Strategy.GuardedLChoice = [[Strategy] &lt; [Strategy] + [Strategy]] {right}\n  Strategy.PrimT = &lt;prim(&lt;String&gt;, &lt;{Strategy \", \"}*&gt;|&lt;{Term \", \"}*&gt;)&gt;\n  Strategy.Some  = &lt;some(&lt;Strategy&gt;)&gt;\n  Strategy.One   = &lt;one(&lt;Strategy&gt;)&gt;\n  Strategy.All   = &lt;all(&lt;Strategy&gt;)&gt;\n\n  SVar.SVar = SId\n\n  Strategy.Let =\n&lt;let\n  &lt;{Def \"\\n\"}*&gt;\nin\n  &lt;Strategy&gt;\nend&gt;\n\n  Strategy.CallT =\n    &lt;&lt;SVar&gt;(&lt;{Strategy \", \"}*&gt;|&lt;{Term \", \"}*&gt;)&gt;\n\n  Strategy.CallDynamic =\n    &lt;call(&lt;Term&gt;|&lt;{Strategy \", \"}*&gt;|&lt;{Term \", \"}*&gt;)&gt; {deprecated(\"Dynamic calls are not supported\")}\n\n  Strategy.ImportTerm = &lt;import-term(&lt;ModName&gt;)&gt;\n\ncontext-free priorities\n  { Strategy.Build\n    Strategy.Match\n  }\n&gt; Strategy.Seq\n&gt; Strategy.GuardedLChoice\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/strategies.sdf3/#modal-h2","title":"strategies.sdf3","text":""},{"location":"stratego.lang/syntax/core/terms.sdf3/","title":"<code>terms.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/core/terms.sdf3</p> <pre><code>module core/terms\n\nimports\n  core/identifiers\n  core/constants\n\ncontext-free sorts ID Var Wld\ncontext-free syntax\n  Var.Var = ID\n  ID      = Id\n  Wld.Wld = \"_\"\n\ncontext-free sorts Term // term with annotations\ncontext-free syntax\n\n  Term      = Var\n  Term      = Wld\n  Term.Anno = &lt;&lt;PreTerm&gt;{^&lt;PreTerm&gt;}&gt;\n  Term.As   = &lt;&lt;Var&gt;@&lt;Term&gt;&gt;\n\ncontext-free sorts PreTerm // term without annotations\ncontext-free syntax\n\n  PreTerm         = Var\n  PreTerm         = Wld\n\n  PreTerm.Int     = Int\n  PreTerm.Real    = Real\n  PreTerm.Str     = String\n  PreTerm.Op      = &lt;&lt;Id&gt;(&lt;{Term \", \"}*&gt;)&gt;\n  PreTerm.OpQ     = &lt;&lt;String&gt;(&lt;{Term \", \"}*&gt;)&gt;\n  PreTerm.Explode = &lt;&lt;Term&gt;#(&lt;Term&gt;)&gt;\n  PreTerm.AsPT    = &lt;&lt;Var&gt;@&lt;PreTerm&gt;&gt;\n\ncontext-free priorities\n  PreTerm.Explode &gt; Term.As,\n  Term.Anno &gt; PreTerm.AsPT\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/core/terms.sdf3/#modal-h2","title":"terms.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/internal.sdf3/","title":"<code>internal.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/internal.sdf3</p> <pre><code>module gradual-types/internal\n\nimports\n  core/identifiers\n  core/constants\n  core/modules\n  core/strategies\n  gradual-types/signatures\n\ncontext-free sorts Str2Lib Str2LibComponent Anno\ncontext-free syntax\n\n  Str2Lib.Str2Lib = [library [ModNamePart]\n    [{Str2LibComponent \"\\n\"}+]\n    [{Module \"\\n\\n\"}+]\n  ]\n\n  Str2LibComponent.Maven = [maven [groupId:JavaId]:[id:JavaId]:[MavenVersion]]\n  Str2LibComponent.Package = [package [PackageName]]\n\n  Anno.Overlay = [overlay]\n\nlexical sorts VersionNumber VersionQualifier MavenVersion PackageName JavaId\nlexical syntax\n\n  MavenVersion = VersionNumber \".\" VersionNumber \".\" VersionNumber VersionQualifier\n  VersionNumber = [0-9]+\n  VersionQualifier = \"-\" [A-Za-z0-9\\-\\.]+\n  PackageName = {JavaId \".\"}+\n  JavaId = [A-Za-z\\_\\$] [A-Za-z0-9\\_\\$]+\n\nlexical restrictions\n\n  VersionQualifier -/- [A-Za-z0-9\\-\\.]\n\ncontext-free sorts ConstrType\ncontext-free syntax\n\n  Def.DefHasType = [[SId] :: [SFunType]]\n\n  Type.IllFormedTermT = [[Id]#([{Type \", \"}*])]\n  Type.EmptyT = [empty]\n  Anno.LocalDef = [localdef]\n  Anno.AmbiguousStrategyResolution = [ambiguous strategy resolves to arities: [Int], [Int]]\n  SType.SEmptyT = [s-empty]\n  Dyn = Type // to allow DynT(&lt;some type&gt;)\n\n  ConstrType.ConstrType = [[{Type \" * \"}+] -&gt; [Type]]\n\ncontext-free sorts ErrorDesc MessageType\ncontext-free syntax\n  MessageType.MTError = [error]\n  MessageType.MTWarning = [warning]\n  MessageType.MTNote = [note]\n\n  ErrorDesc.CallDynamicNotSupported = [The dynamic `call(name|sargs|targs)` construct is no longer supported.]\n  ErrorDesc.TermVariableTypedWithStrategyType = [This term variable was given a strategy type.]\n  ErrorDesc.StrategyVariableTypedWithTermType = [This strategy variable was given a term type.]\n  ErrorDesc.DuplicateTypeDefinition = [Duplicate type definition.]\n  ErrorDesc.MissingDefinitionForTypeDefinition = [Cannot find definition for this type definition.]\n  ErrorDesc.ProceedWrongNumberOfArguments = [Wrong number of arguments to proceed: ([Int]|[Int]).]\n  ErrorDesc.ProceedInNonExtendStrategy = [Cannot call proceed in a strategy or rule defined without the `extend` keyword.]\n  ErrorDesc.CallStrategyArgumentTakesParameters = [This call takes parameters, it has type: [SFunType].]\n  ErrorDesc.AmbiguousStrategyResolution = [Call to strategy was ambiguous, could resolve to the following: [{SFunType \", \"}+].]\n\n  ErrorDesc.NormalDefinitionOverlapsWithExternal = [Definition of strategy overlaps with definition of external strategy.]\n  ErrorDesc.NormalDefinitionOverlapsWithInternal = [Definition of strategy overlaps with definition of internal strategy.]\n  ErrorDesc.OverrideDefinitionWithoutExternal = [Cannot find external strategy to override.]\n  ErrorDesc.ExtendDefinitionWithoutExternal = [Cannot find external strategy to extend.]\n\n  ErrorDesc.NoInjectionBetween = [Cannot convert from [Type] to [Type] automatically, no known injection.]\n  ErrorDesc.CastInserted = [Converting from [Type] to [Type] with a cast.]\n  ErrorDesc.SCastInserted = [Converting from [SType] to [SType] with a cast.]\n  ErrorDesc.VariableBoundToIncompatibleType = [This variable has type [Type], which cannot be converted to [Type] automatically.]\n  ErrorDesc.NoLUBBetween = [Expected [Type] and [Type] to have a shared least upper bound but none was found.]\n  ErrorDesc.STypeMismatch = [Expected [SType], but got [SType].]\n  ErrorDesc.UnresolvedLocal = [Undefined local variable.]\n  ErrorDesc.UnresolvedSort = [Undefined sort with arity [Int].]\n  ErrorDesc.UnresolvedSortVar = [Undefined sort variable.]\n  ErrorDesc.UnresolvedConstructor = [Undefined constructor with arity [Int] and type [Type].]\n  ErrorDesc.UnresolvedStrategy = [Undefined strategy with arity [Int]/[Int].]\n  ErrorDesc.AmbiguousConstructorUse = [Ambiguous use of constructor, could be the following types: [{Type \", \"}+]]\n  ErrorDesc.UnboundTypeVar = [No instantiation found for type variable [String]]\n  ErrorDesc.LiteralCastFail = [Cannot compile literal failing cast]\n  ErrorDesc.MissingParsingInfoOnStringQuotation = [String quotation does not have parser information required to figure out indentation.]\n  ErrorDesc.StrategyCongruenceOverlap = [Strategy overlaps with congruence for constructor of same name.]\n  ErrorDesc.GadtSort = [Must use all unique sort variables as sort arguments, GADTs are not supported.]\n\n  ErrorDesc.AsInBuildTerm = [The @ pattern may not be used in build context.]\n  ErrorDesc.WldInBuildTerm = [The _ pattern may not be used in build context.]\n  ErrorDesc.BuildDefaultInBuildTerm = [The _name pattern may not be used in build context.]\n  ErrorDesc.BuildDefaultInMatchTerm = [The _name pattern may not be used in match context.]\n  ErrorDesc.StringQuotationInMatchTerm = [A string quotation pattern may not be used in match context.]\n\n  ErrorDesc.NonStringOrListInExplodeConsPosition = [Expected type string or list, but got [Type].]\n  ErrorDesc.NonListInAnno = [Expected list, but got [Type].]\n  ErrorDesc.MultipleAppsInMatch = [Multiple projections in one pattern, only one is actually returned. ]\n\n  ErrorDesc.MatchNotSpecificEnoughForTP = [Cannot infer specific type for TP rule match. Found result: [Type]. ]\n\n  ErrorDesc.UnsupportedCastRequiredInDynamicRule = [Pattern induces cast, but cast is not supported in this position. ]\n\n  ErrorDesc.DynRuleOverlapError = [Overlapping left-hand-sides for dynamic rule '[Id]': [String] in [String] overlaps with [String] in [String]. ]\n  ErrorDesc.CannotCastToRigidTypeVar = [Cannot cast [Type] to type [Type], its type is not known at run-time in this position. ]\n  ErrorDesc.WithClauseInDynRule = [Cannot use with clauses in dynamic rules. ]\n  ErrorDesc.ConstantCongruence = [Simple matching congruence: prefix with '?'. Or with '!' if you meant to build. ]\n\n  ErrorDesc.WldInOverlay = [Wildcard not allowed in overlay, add a default value after the underscore. ]\n  ErrorDesc.AsInOverlay = [As pattern not allowed in overlay. ]\n  ErrorDesc.StringQuotationInOverlay = [The string quotation pattern may not be used in overlay. ]\n  ErrorDesc.MissingTypeDefinition = [Missing type definition. ]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/internal.sdf3/#modal-h2","title":"internal.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/main.sdf3/","title":"<code>main.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/main.sdf3</p> <pre><code>module gradual-types/main\n\nimports\n  gradual-types/modules\n  gradual-types/signatures\n  gradual-types/strategies\n  gradual-types/terms\n  gradual-types/overlays\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/main.sdf3/#modal-h2","title":"main.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/modules.sdf3/","title":"<code>modules.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/modules.sdf3</p> <pre><code>module gradual-types/modules\nimports\n  core/identifiers\n  core/strategies\n  gradual-types/signatures\n\ncontext-free syntax\n\n  Def.DefHasTypeNoArgs = [[SId] :: [SSimpleFunType]]\n  Def.DefHasType       = [[SId]([{SType \", \"}*]) :: [SSimpleFunType]]\n  Def.DefHasTType      = [[SId]([{SType \", \"}*] | [{Type \", \"}*]) :: [SSimpleFunType]]\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/modules.sdf3/#modal-h2","title":"modules.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/overlays.sdf3/","title":"<code>overlays.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/overlays.sdf3</p> <pre><code>module gradual-types/overlays\nimports\n  core/identifiers\n  core/signatures\n  gradual-types/signatures\n  sugar/overlays\n\ncontext-free syntax\n  Overlay.OverlayDeclNoArgs =\n    [[Id] :: [ConstType]]\n\n  Overlay.OverlayDecl =\n    [[Id]([{Type \", \"}*]) :: [ConstType]]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/overlays.sdf3/#modal-h2","title":"overlays.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/signatures.sdf3/","title":"<code>signatures.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/signatures.sdf3</p> <pre><code>module gradual-types/signatures\n\nimports\n  core/identifiers\n  core/signatures\n\ncontext-free sorts Type SortT Dyn\ncontext-free syntax\n  ConstType.ConstDynT = Dyn\n  Dyn.Dyn           = [?]\n  Type.TupleT       = [[Type] * [{Type \" * \"}+]]\n  Type.DynT         = Dyn\n  Type.StringT      = \"string\"\n  Type.IntT         = \"int\"\n  Type.RealT        = \"real\"\n  Type.BlobT        = \"blob\"\n  Type              = [([Type])] {bracket}\n  Type              = SortT\n  SortT.SortT       = [[Id]([{Type \", \"}*])]\n  SortT.SortTNoArgs = UCID\n  SortT             = \"TP\" {reject}\n  SortT.SortTVar    = SortVar\n\n  SortArg.SATupleT = [[Sort] * [{Sort \" * \"}+]]\n  SortArg.SADynT   = Dyn\n\ncontext-free priorities\n  Type.TupleT &lt;0&gt; .&gt; Type.TupleT,\n  {Type \"*\"}+ = Type &lt;0&gt; .&gt; Type.TupleT,\n  {Type \"*\"}+ = {Type \"*\"}+ \"*\" Type &lt;2&gt; .&gt; Type.TupleT\n\ncontext-free sorts SType SFunType SSimpleFunType FunTType\ncontext-free syntax\n  SType.SDyn             = [?]\n  SType                  = SFunType\n\n  SSimpleFunType.TP                 = [TP]\n  SSimpleFunType.FunNoArgsType      = [[Type] -&gt; [Type]]\n\n  SFunType          = SSimpleFunType\n  SFunType.SFunType = [([{SType \", \"}*]) [SSimpleFunType]]\n  SFunType          = FunTType\n\n  FunTType.FunTType = [([{SType \", \"}*] | [{Type \", \"}*]) [SSimpleFunType]]\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/signatures.sdf3/#modal-h2","title":"signatures.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/strategies.sdf3/","title":"<code>strategies.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/strategies.sdf3</p> <pre><code>module gradual-types/strategies\n\nimports\n  gradual-types/signatures\n  core/identifiers\n  core/strategies\n  core/terms\n\ntemplate options\n  keyword -/- [a-zA-Z0-9\\'\\-\\_]\n  tokenize: \")(|\"\n\n\ncontext-free sorts Coercion SCoercion Proxy\ncontext-free syntax\n// Extension for highlighting casts\n  Strategy.Cast   = [cast([Coercion])]\n  Strategy.TypeTest   = [is([Type])]\n//  Strategy.TypedCong = [[TypedId]([{Strategy \", \"}*])]\n\n  Coercion.FailC = [fail]\n  Coercion.IdC = [id]\n  Coercion.RuntimeCheck = Type\n\n  SCoercion.SFail         = [fail]\n  SCoercion.SId           = [id]\n  SCoercion.SRuntimeCheck = SType\n\n//  TypedId.TypedId = [[SortT].[Id]]\n\n  Strategy     = Proxy\n  Proxy.Proxy  = [proxy([Coercion], [Coercion])([SVar])]\n  Proxy.ProxyT = [proxy([{SCoercion \", \"}*] | [{Coercion \", \"}*])([Coercion], [Coercion])([SVar])]\n\n  SVar = \"cast\" {reject}\n\ncontext-free sorts TypedSVar TypedTVar\ncontext-free syntax\n\n  StrategyDef.ExtTypedDef =\n    [external [MaybeEmptySId] :: [FunTType]]\n\n  StrategyDef.ExtTypedDefInl =\n    [external [MaybeEmptySId]([{ID \", \"}*] | [{ID \", \"}*]) :: [FunTType] =\n  [Strategy]]\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/strategies.sdf3/#modal-h2","title":"strategies.sdf3","text":""},{"location":"stratego.lang/syntax/gradual-types/terms.sdf3/","title":"<code>terms.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/gradual-types/terms.sdf3</p> <pre><code>module gradual-types/terms\nimports\n  core/terms\n  sugar/terms\n  gradual-types/signatures\n\ncontext-free syntax\n\n  Term.TypeAscription = [[Term] :: [Type]]\n\ncontext-free priorities\n\n  { Term.App PreTerm.AppPT Term.BuildDefault } &gt; Term.TypeAscription\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/gradual-types/terms.sdf3/#modal-h2","title":"terms.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/constants.sdf3/","title":"<code>constants.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/constants.sdf3</p> <pre><code>module sugar/constants\n\nimports\n  core/identifiers\n  core/constants\n  sugar/string-quotations\n\nlexical sorts Char CharChar\nlexical syntax\n  Char     = \"'\" CharChar \"'\"\n  CharChar = ~[\\'\\\\\\n\\r]\n  CharChar = [\\\\] [tnrbf\\\"\\'\\\\]\n  Id       = Char {reject}\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/constants.sdf3/#modal-h2","title":"constants.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/dynamic-rules.sdf3/","title":"<code>dynamic-rules.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/dynamic-rules.sdf3</p> <pre><code>module sugar/dynamic-rules\n\nimports\n  core/identifiers\n  core/terms\n  core/signatures\n  core/strategies\n  sugar/strategies\n  sugar/rules\n\ntemplate options\n  tokenize: \")(\"\n\ncontext-free sorts ScopeLabels\ncontext-free syntax\n  Strategy.DynRuleScope =\n&lt;{| &lt;ScopeLabels&gt;\n: &lt;Strategy&gt;\n|}&gt;\n\n  ScopeLabels = {DynRuleScopeId \", \"}*\n\n  ScopeLabels.ScopeLabels = &lt;~&lt;Term&gt;&gt;\n\ncontext-free sorts DynRuleDef DynRuleId DynRuleScopeId\ncontext-free syntax\n\n  Strategy.GenDynRules =\n    &lt;rules(&lt;DynRuleDef*&gt;)&gt;\n  DynRuleDef.AddScopeLabel =\n    &lt;&lt;SId&gt; + &lt;Term&gt;&gt;\n  DynRuleDef.UndefineDynRule =\n    &lt;&lt;DynRuleId&gt; :- &lt;Term&gt;&gt;\n  DynRuleDef.SetDynRule =\n    &lt;&lt;DynRuleId&gt; : &lt;Rule&gt;&gt;\n  DynRuleDef.AddDynRule =\n    &lt;&lt;DynRuleId&gt; :+ &lt;Rule&gt;&gt;\n  DynRuleDef.SetDynRuleMatch =\n    &lt;&lt;DynRuleId&gt; : &lt;Term&gt;&gt;\n  DynRuleDef.DynRuleAssign =\n    &lt;&lt;DynRuleId&gt; := &lt;Term&gt;&gt;\n  DynRuleDef.DynRuleAssignAdd =\n    &lt;&lt;DynRuleId&gt; :+= &lt;Term&gt;&gt;\n  DynRuleDef.SetDynRuleDepends =\n    &lt;&lt;DynRuleId&gt; : &lt;Rule&gt; depends on &lt;Term&gt;&gt;\n  DynRuleId.LabeledDynRuleId =\n    &lt;&lt;RuleDec&gt; . &lt;Term&gt;&gt;\n  DynRuleId.AddLabelDynRuleId =\n    &lt;&lt;RuleDec&gt; + &lt;Term&gt;&gt;\n  DynRuleId.DynRuleId = RuleDec\n  DynRuleScopeId.LabeledDynRuleScopeId =\n    &lt;&lt;Id&gt; . &lt;Term&gt;&gt;\n  DynRuleScopeId.DynRuleScopeId = Id\n\ncontext-free sorts RuleDec\ncontext-free syntax\n\n  RuleDec.RDecNoArgs = SId\n  RuleDec.RDec = &lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt; )&gt;\n  RuleDec.RDecT = &lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt; | &lt;{Typedid \", \"}*&gt;)&gt;\n\ncontext-free sorts RuleNames\ncontext-free syntax\n\n  RuleNames = {SId \", \"}*\n  RuleNames.RuleNames = &lt;~&lt;Term&gt;&gt;\n  Strategy.DynRuleIntersectFix = &lt;/&lt;RuleNames&gt;\\\\* &lt;Strategy&gt;&gt;\n\nsyntax\n  // no space after RuleNames\n  Strategy-CF.DynRuleUnionFix =\n  \"\\\\\" LAYOUT?-CF RuleNames-CF \"/*\" LAYOUT?-CF Strategy-CF\n\n\n  // 1 space after RuleNames\n  Strategy-CF.DynRuleUnionFix1 =\n  \"\\\\\" LAYOUT?-CF RuleNames-CF \" /*\" LAYOUT?-CF Strategy-CF\n\n  // no space after RuleNames\n  Strategy-CF.DynRuleIntersectUnionFix =\n  \"/\"  LAYOUT?-CF RuleNames-CF LAYOUT?-CF \"\\\\\"\n      LAYOUT?-CF RuleNames-CF \"/*\" LAYOUT?-CF Strategy-CF\n\n  // 1 space after RuleNames\n  Strategy-CF.DynRuleIntersectUnionFix1 =\n  \"/\" LAYOUT?-CF RuleNames-CF LAYOUT?-CF \"\\\\\"\n      LAYOUT?-CF RuleNames-CF \" /*\" LAYOUT?-CF Strategy-CF\n\ncontext-free syntax\n\n  Strategy.DynRuleIntersect =\n    &lt;&lt;Strategy&gt; /&lt;RuleNames&gt;\\\\ &lt;Strategy&gt;&gt; {right}\n  Strategy.DynRuleUnion =\n    &lt;&lt;Strategy&gt; \\\\&lt;RuleNames&gt;/ &lt;Strategy&gt;&gt; {right}\n  Strategy.DynRuleIntersectUnion =\n    &lt;&lt;Strategy&gt; /&lt;RuleNames&gt;\\\\&lt;RuleNames&gt;/ &lt;Strategy&gt;&gt; {right}\n\ncontext-free priorities\n     Strategy.BA\n   &gt; { Strategy.DynRuleIntersectFix Strategy.DynRuleUnionFix }\n   &gt; Strategy.AM\n   &gt; Strategy.DynRuleIntersect\n   &gt; Strategy.DynRuleUnion\n   &gt; Strategy.DynRuleIntersectUnion\n   &gt; Strategy.Seq\n\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/dynamic-rules.sdf3/#modal-h2","title":"dynamic-rules.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/main.sdf3/","title":"<code>main.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/main.sdf3</p> <pre><code>module sugar/main\n\nimports\n  core/identifiers\n  core/modules\n\n  sugar/constants\n  sugar/signatures\n  sugar/modules\n  sugar/terms\n  sugar/strategies\n  sugar/rules\n  sugar/dynamic-rules\n  sugar/overlays\n\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/main.sdf3/#modal-h2","title":"main.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/modules.sdf3/","title":"<code>modules.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/modules.sdf3</p> <pre><code>module sugar/modules\nimports\n  core/modules\n  core/strategies\n  sugar/overlays\n  sugar/rules\n\ncontext-free syntax\n  Decl.Rules =\n&lt;rules\n  &lt;{Def \"\\n\\n\"}*&gt;&gt;\n\n  Decl.Overlays =\n&lt;overlays\n  &lt;{Overlay \"\\n\\n\"}*&gt;&gt;\n\n  Def = &lt;&lt;RuleDef&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/modules.sdf3/#modal-h2","title":"modules.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/overlays.sdf3/","title":"<code>overlays.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/overlays.sdf3</p> <pre><code>module sugar/overlays\nimports\n  core/identifiers\n  core/terms\n\ncontext-free sorts Overlay\ncontext-free syntax\n  Overlay.OverlayNoArgs = &lt;&lt;Id&gt; = &lt;Term&gt;&gt;\n\n  Overlay.Overlay =\n    &lt;&lt;Id&gt;(&lt;{Id \", \"}*&gt;) = &lt;Term&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/overlays.sdf3/#modal-h2","title":"overlays.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/rules.sdf3/","title":"<code>rules.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/rules.sdf3</p> <pre><code>module sugar/rules\n\n  imports\n    core/identifiers\n    core/signatures\n    core/terms\n    core/strategies\n    sugar/terms\n    sugar/strategies\n\ntemplate options\n  tokenize: \")(|\"\n\ncontext-free sorts RuleDef RDefT RDefP\ncontext-free syntax\n  RuleDef.RDefNoArgs =\n&lt;&lt;SId&gt;:\n  &lt;Rule&gt;&gt;\n\n  Def.AnnoRuleDef =\n    &lt;&lt;Anno+&gt; &lt;RuleDef&gt;&gt;\n\n  RuleDef.RDef =\n&lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt;):\n  &lt;Rule&gt;&gt;\n\n  RuleDef = RDefT\n  RDefT.RDefT =\n&lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt; | &lt;{Typedid \", \"}*&gt;):\n  &lt;Rule&gt;&gt;\n\n  // Rule definition with pattern matched term parameters\n  RuleDef = RDefP\n  RDefP.RDefP =\n&lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt; | &lt;{Term \", \"}+&gt;):\n  &lt;Rule&gt;&gt;\n  RDefP = RDefT {reject}\n\ncontext-free sorts Rule RuleCond\ncontext-free syntax\n\n  Rule.Rule = [[Term] -&gt; [Term]\n  [{RuleCond \"\\n\"}*]]\n\n  RuleCond.WhereClause =\n&lt;where\n  &lt;Strategy&gt;&gt;\n  RuleCond.WithClause =\n&lt;with\n  &lt;Strategy&gt;&gt;\n\n\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/rules.sdf3/#modal-h2","title":"rules.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/signatures.sdf3/","title":"<code>signatures.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/signatures.sdf3</p> <pre><code>module sugar/signatures\n\nimports\n  core/signatures\n  sugar/constants\n  core/identifiers\n\ncontext-free syntax\n  Sort.SortList   = &lt;[&lt;{Sort \", \"}*&gt; ]&gt; {deprecated(\"This syntax never had real meaning and will be dropped\")}\n  Sort.SortListTl = &lt;[&lt;{Sort \", \"}*&gt; | &lt;Sort&gt; ]&gt; {deprecated(\"This syntax never had real meaning and will be dropped\")}\n  Sort.SortTuple  = &lt;(&lt;{Sort \", \"}*&gt; )&gt; {deprecated(\"This syntax is being replaced\")}\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/signatures.sdf3/#modal-h2","title":"signatures.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/strategies.sdf3/","title":"<code>strategies.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/strategies.sdf3</p> <pre><code>module sugar/strategies\nimports\n  core/identifiers\n  core/constants\n  core/strategies\n  core/terms\n  sugar/terms\n  sugar/rules\n  sugar/constants\n  sugar/signatures\n\ntemplate options\n  tokenize: \")(|\"\n\ncontext-free sorts SDefP\ncontext-free syntax\n  StrategyDef.SDefNoArgs =\n&lt;&lt;SId&gt; =\n  &lt;Strategy&gt;&gt;\n\n  StrategyDef.SDef =\n&lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt;) =\n  &lt;Strategy&gt;&gt;\n\n  // Strategy definition with pattern matched term parameters\n  StrategyDef = SDefP\n  SDefP.SDefP =\n&lt;&lt;SId&gt;(&lt;{Typedid \", \"}*&gt;|&lt;{Term \",\"}+&gt;) =\n  &lt;Strategy&gt;&gt;\n  SDefP = SDefT {reject}\n\ncontext-free syntax\n  Typedid.DefaultVarDec = ID\n\ncontext-free sorts Call With\ncontext-free syntax\n\n  Strategy = Call\n  Call.Call = &lt;&lt;SVar&gt;(&lt;{Strategy \",\"}*&gt;)&gt;\n  Call = With {reject}\n  Strategy.ScopeDefault = &lt;{&lt;Strategy&gt;}&gt;\n  Strategy.BA = [&lt;[Strategy]&gt; [Term]]\n  Strategy.LChoice = [[Strategy] &lt;+ [Strategy]] {right}\n\n  Strategy.Rec        = &lt;rec &lt;SId&gt;( &lt;Strategy&gt; )&gt;\n  Strategy.Not        = &lt;not(&lt;Strategy&gt;)&gt;\n  Strategy.Where      = &lt;where(&lt;Strategy&gt;)&gt;\n  Strategy = With\n  With.With       = &lt;with(&lt;Strategy&gt;)&gt;\n  Strategy.Test       = &lt;test(&lt;Strategy&gt;)&gt; {deprecated(\"Use `where` instead\")}\n  Strategy.PrimNoArgs = &lt;prim(&lt;String&gt;)&gt;\n  Strategy.Prim       = &lt;prim(&lt;String&gt;, &lt;{Term \", \"}*&gt;)&gt;\n\ncontext-free syntax // congruence operators\n\n  Strategy.StrCong        = &lt;&lt;String&gt;&gt;\n  Strategy.IntCong        = &lt;&lt;Int&gt;&gt;\n  Strategy.RealCong       = &lt;&lt;Real&gt;&gt;\n  Strategy.CharCong       = &lt;&lt;Char&gt;&gt;\n  Strategy.CongQ          = &lt;&lt;String&gt;(&lt;{Strategy \", \"}*&gt;)&gt;\n  Strategy.EmptyTupleCong = &lt;( )&gt;\n  Strategy                = &lt;(&lt;Strategy&gt;)&gt; {bracket}\n  Strategy.TupleCong      = &lt;(&lt;Strategy&gt;, &lt;{Strategy \", \"}+&gt; )&gt;\n  Strategy.ListCongNoTail = &lt;[&lt;{Strategy \", \"}*&gt; ]&gt;\n  Strategy.ListCong       = &lt;[&lt;{Strategy \", \"}*&gt; | &lt;Strategy&gt; ]&gt;\n  Strategy.ExplodeCong    = &lt;&lt;Strategy&gt;#(&lt;Strategy&gt;)&gt;\n  Strategy.AM             = [[Strategy] =&gt; [Term]]\n  Strategy.Assign         = &lt;&lt;Term&gt; := &lt;Term&gt;&gt;\n\n  Strategy.AnnoCong       = &lt;&lt;Strategy&gt;{&lt;Strategy&gt;}&gt;\n\n// Syntactic sugar sugar\n\ncontext-free syntax\n\n  Strategy.CallNoArgs = &lt;&lt;SVar&gt;&gt;\n  Strategy.LRule      = &lt;\\\\&lt;Rule&gt;\\\\&gt;\n  Strategy.SRule      = &lt;(&lt;Rule&gt;)&gt;\n  Strategy.Choice     = &lt;&lt;Strategy&gt; + &lt;Strategy&gt;&gt; {right}\n  Strategy.RChoice    = [[Strategy] +&gt; [Strategy]] {right, deprecated(\"Flip your arguments and use &lt;+\")}\n  Strategy.Proceed    = &lt;proceed(&lt;{Strategy \", \"}+&gt;)&gt;\n  Strategy.CondChoice = &lt;if &lt;Strategy&gt; then &lt;Strategy&gt; else &lt;Strategy&gt; end&gt;\n  Strategy.IfThen     = &lt;if &lt;Strategy&gt; then &lt;Strategy&gt; end&gt;\n  Strategy.LTrySome   = [[Strategy] &lt;* [Strategy]] {left}\n\ncontext-free sorts SwitchCase\ncontext-free syntax\n  Strategy.SwitchChoiceNoOtherwise =\n&lt;switch &lt;Strategy&gt;\n  &lt;{SwitchCase \"\\n\"}*&gt;\nend&gt;\n\n  Strategy.SwitchChoice =\n&lt;switch &lt;Strategy&gt;\n  &lt;{SwitchCase \"\\n\"}*&gt;\n  otherwise : &lt;Strategy&gt;\nend&gt;\n\n  SwitchCase.SwitchCase =\n&lt;case &lt;Strategy&gt;:\n  &lt;Strategy&gt;&gt;\n\ncontext-free priorities\n  { Strategy.AnnoCong Strategy.ExplodeCong }\n&gt; { Strategy.Match Strategy.Build }\n&gt; Strategy.BA\n&gt; Strategy.AM\n&gt; Strategy.Seq\n&gt; Strategy.LTrySome\n&gt; {right:\n   Strategy.Choice\n   Strategy.LChoice\n   Strategy.RChoice\n   Strategy.GuardedLChoice\n  }\n\n// Strategy.AnnoCong and Strategy.ExplodeCong are same syntax as Term.AnnoList and Term.Explode\n//   respectively. So we need to disambiguate that we prefer the Term version to be on the\n//   right-hand side of Strategy productions that have a Term as the right-most part of their rule,\n//   and this is expressed by that we don't want such a production inside AnnoCong or ExplodeCong as\n//   the left-hand child.\ncontext-free priorities\n  Strategy.AnnoCong &lt;0&gt;\n  .&gt; { Strategy.Match Strategy.Build Strategy.Assign Strategy.BA Strategy.AM },\n\n  Strategy.ExplodeCong &lt;0&gt;\n  .&gt; { Strategy.Match Strategy.Build Strategy.Assign Strategy.BA Strategy.AM }\n\n// Normal priorities work on operator priority semantics using the outer recursive positions. \n//   Strategy.GuardedLChoice and Strategy.Choice have a larger overlap, therefore we need to\n//   disambiguate that we want `a &lt; b + (c + d)` not `a &lt; (b + c) + d` when there are no\n//   parentheses. Therefore we disallow Strategy.Choice as the second argument to\n//   Stratego.GuardedLChoice. This _should_ be under index &lt;1&gt;, but works as we want it under &lt;2&gt;,\n//   which is probably a bug in SDF3 or JSGLR2?\ncontext-free priorities\n  Strategy.GuardedLChoice &lt;2&gt;\n  .&gt; Strategy.Choice\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/strategies.sdf3/#modal-h2","title":"strategies.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/string-quotations.sdf3/","title":"<code>string-quotations.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/string-quotations.sdf3</p> <pre><code>module sugar/string-quotations\n\nimports core/terms\n\ncontext-free sorts\n  StringQuotation\n  StringQuotedPart1\n  StringQuotedPart2\n  StringQuotedPart3\n  StringQuotedPart4\n\ncontext-free syntax\n  PreTerm = StringQuotation\n\n  StringQuotedPart1.QStr1 = StringQuotedChars1\n  StringQuotedPart2.QStr2 = StringQuotedChars2\n  StringQuotedPart3.QStr3 = StringQuotedChars3\n  StringQuotedPart4.QStr4 = StringQuotedChars4\n\n  StringQuotedPart1.QDollar1 = Dollar1\n  StringQuotedPart2.QDollar2 = Dollar2\n  StringQuotedPart3.QDollar3 = Dollar3\n  StringQuotedPart4.QDollar4 = Dollar4\n\n  StringQuotedPart1.QBr1 = QuotedBracket1\n  StringQuotedPart2.QBr2 = QuotedBracket2\n  StringQuotedPart3.QBr3 = QuotedBracket3\n  StringQuotedPart4.QBr4 = QuotedBracket4\n\nlexical sorts\n  StringQuotedChars1 Dollar1 QuotedBracket1\n  StringQuotedChars2 Dollar2 QuotedBracket2\n  StringQuotedChars3 Dollar3 QuotedBracket3\n  StringQuotedChars4 Dollar4 QuotedBracket4\n\nlexical syntax\n  StringQuotedChars1 = ~[\\[\\]\\$]+\n  StringQuotedChars2 = ~[\\{\\}\\$]+\n  StringQuotedChars3 = ~[\\(\\)\\$]+\n  StringQuotedChars4 = ~[\\&lt;\\&gt;\\$]+\n\n  Dollar1 = \"$\"\n  Dollar2 = \"$\"\n  Dollar3 = \"$\"\n  Dollar4 = \"$\"\n\n  QuotedBracket1 = \"$\" [\\[\\]] \"$\"\n  QuotedBracket2 = \"$\" [\\{\\}] \"$\"\n  QuotedBracket3 = \"$\" [\\(\\)] \"$\"\n  QuotedBracket4 = \"$\" [\\&lt;\\&gt;] \"$\"\n\nlexical restrictions\n  StringQuotedChars1 -/- ~[\\[\\]\\$]\n  StringQuotedChars2 -/- ~[\\{\\}\\$]\n  StringQuotedChars3 -/- ~[\\(\\)\\$]\n  StringQuotedChars4 -/- ~[\\&lt;\\&gt;\\$]\n\n  Dollar1 -/- [\\[\\]].[\\$]\n  Dollar2 -/- [\\{\\}].[\\$]\n  Dollar3 -/- [\\(\\)].[\\$]\n  Dollar4 -/- [\\&lt;\\&gt;].[\\$]\n\nsyntax\n  StringQuotation-CF.StringQuotation1 = \"$\" \"[\" StringQuotedPart1-CF* \"]\"\n  StringQuotation-CF.StringQuotation2 = \"$\" \"{\" StringQuotedPart2-CF* \"}\"\n  StringQuotation-CF.StringQuotation3 = \"$\" \"(\" StringQuotedPart3-CF* \")\"\n  StringQuotation-CF.StringQuotation4 = \"$\" \"&lt;\" StringQuotedPart4-CF* \"&gt;\"\n\n  StringQuotedPart1-CF.StringEscape1 = \"[\" LAYOUT?-CF Term-CF LAYOUT?-CF \"]\"\n  StringQuotedPart2-CF.StringEscape2 = \"{\" LAYOUT?-CF Term-CF LAYOUT?-CF \"}\"\n  StringQuotedPart3-CF.StringEscape3 = \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n  StringQuotedPart4-CF.StringEscape4 = \"&lt;\" LAYOUT?-CF Term-CF LAYOUT?-CF \"&gt;\"\n\n// The following is the AST that is expected by Stratego compiler, but the Padding literal was\n//   filled by a hack in SDF2/JSGLR1 and is now done in postprocessing.\ncontext-free sorts\n  InternalStringQuotation\n  InternalStringQuotedPart1\n  InternalStringQuotedPart2\n  InternalStringQuotedPart3\n  InternalStringQuotedPart4\nsyntax\n\n  InternalStringQuotation-CF.StringQuotation1 = \"$\" \"[\" Padding-LEX InternalStringQuotedPart1-CF* \"]\"\n  InternalStringQuotation-CF.StringQuotation2 = \"$\" \"{\" Padding-LEX InternalStringQuotedPart2-CF* \"}\"\n  InternalStringQuotation-CF.StringQuotation3 = \"$\" \"(\" Padding-LEX InternalStringQuotedPart3-CF* \")\"\n  InternalStringQuotation-CF.StringQuotation4 = \"$\" \"&lt;\" Padding-LEX InternalStringQuotedPart4-CF* \"&gt;\"\n\n  InternalStringQuotedPart1-CF.StringEscape1 = Padding-LEX \"[\" LAYOUT?-CF Term-CF LAYOUT?-CF \"]\"\n  InternalStringQuotedPart2-CF.StringEscape2 = Padding-LEX \"{\" LAYOUT?-CF Term-CF LAYOUT?-CF \"}\"\n  InternalStringQuotedPart3-CF.StringEscape3 = Padding-LEX \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n  InternalStringQuotedPart4-CF.StringEscape4 = Padding-LEX \"&lt;\" LAYOUT?-CF Term-CF LAYOUT?-CF \"&gt;\"\n\nlexical sorts Padding\nlexical syntax\n\n  Padding = ' '+\n\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/string-quotations.sdf3/#modal-h2","title":"string-quotations.sdf3","text":""},{"location":"stratego.lang/syntax/sugar/terms.sdf3/","title":"<code>terms.sdf3</code>","text":"<p> pdmosses/stratego/stratego.lang/syntax/sugar/terms.sdf3</p> <pre><code>module sugar/terms\nimports\n  core/terms\n  core/identifiers\n  sugar/constants\n  sugar/strategies\n\ncontext-free syntax\n  ID.ListVar        = LId\n\ncontext-free syntax\n\n  Term.BuildDefault = &lt;_&lt;Term&gt;&gt;\n  Term.AnnoList     = &lt;&lt;PreTerm&gt;{&lt;{Term \", \"}*&gt;}&gt;\n  Term.NoAnnoList   = PreTerm\n  Term.App          = [&lt;[Strategy]&gt; [Term]]\n  Term.RootApp      = [&lt;[Strategy]&gt;]\n\ncontext-free syntax\n\n  PreTerm.Char      = Char\n  PreTerm.AppPT     = [&lt;[Strategy]&gt; [Term]]\n  PreTerm.RootAppPT = [&lt;[Strategy]&gt;]\n  PreTerm.Tuple     = &lt;(&lt;{Term \", \"}*&gt;)&gt;\n  PreTerm.List      = &lt;[&lt;{Term \", \"}*&gt;]&gt;\n  PreTerm.ListTail  = &lt;[&lt;{Term \", \"}+&gt; | &lt;Term&gt;]&gt;\n\n  PreTerm.BuildDefaultPT = &lt;_&lt;PreTerm&gt;&gt;\n\ncontext-free priorities\n// replacement for prefer on Term duplicates of PreTerm rules\n  Term.NoAnnoList = PreTerm &lt;0&gt; .&gt; {\n    PreTerm = Var\n    PreTerm = Wld\n  }\n, Term.NoAnnoList &lt;0&gt; .&gt; {\n    PreTerm.AsPT\n    PreTerm.AppPT\n    PreTerm.RootAppPT\n    PreTerm.BuildDefaultPT\n  }\n// AnnoList binds tighter\n, Term.AnnoList &gt; {\n    PreTerm.AsPT\n    PreTerm.AppPT\n  }\n, Term.Anno &gt; PreTerm.AppPT\n, PreTerm.Explode &gt; { Term.App PreTerm.AppPT Term.BuildDefault PreTerm.BuildDefaultPT }\n</code></pre> \u00d7"},{"location":"stratego.lang/syntax/sugar/terms.sdf3/#modal-h2","title":"terms.sdf3","text":""}]}